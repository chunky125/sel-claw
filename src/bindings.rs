#![no_std]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

// Allow std in tests
#[cfg(test)]
#[macro_use]
extern crate std;

mod compile_time_assertions;

type seL4_CPtr = usize;
type seL4_Word = usize;
type seL4_Int8 = i8;
type seL4_Int16 = i16;
type seL4_Int32 = i32;
type seL4_Int64 = i64;
type seL4_Uint8 = u8;
type seL4_Uint16 = u16;
type seL4_Uint32 = u32;
type seL4_Uint64 = u64;

pub const seL4_WordBits: usize = core::mem::size_of::<usize>() * 8;

#[cfg(any(target_arch = "arm", target_arch = "x86"))]
mod ctypes {
    pub type c_char = i8;
    pub type c_uint = u32;
    pub type c_int = i32;
    pub type c_ulong = u32;
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
pub mod ctypes {
    pub type c_char = i8;
    pub type c_uint = u32;
    pub type c_int = i32;
    pub type c_ulong = u64;
}

// bindgen generated tests, https://github.com/rust-lang/rust-bindgen/issues/1651
#[cfg(test)]
include!(concat!(env!("OUT_DIR"), "/generated_tests.rs"));
use super::*;

/* automatically generated by rust-bindgen */

pub const CONFIG_ARM_HIKEY_OUTSTANDING_PREFETCHERS: u32 = 0;
pub const CONFIG_ARM_HIKEY_PREFETCHER_STRIDE: u32 = 0;
pub const CONFIG_ARM_HIKEY_PREFETCHER_NPFSTRM: u32 = 0;
pub const CONFIG_ARCH_AARCH64: u32 = 1;
pub const CONFIG_ARCH_ARM: u32 = 1;
pub const CONFIG_WORD_SIZE: u32 = 64;
pub const CONFIG_USER_TOP: u32 = 2684354560;
pub const CONFIG_PLAT_QEMU_ARM_VIRT: u32 = 1;
pub const CONFIG_ARM_CORTEX_A53: u32 = 1;
pub const CONFIG_ARCH_ARM_V8A: u32 = 1;
pub const CONFIG_ARM_PA_SIZE_BITS_40: u32 = 1;
pub const CONFIG_ARM_ICACHE_VIPT: u32 = 1;
pub const CONFIG_ARM_HYPERVISOR_SUPPORT: u32 = 1;
pub const CONFIG_L1_CACHE_LINE_SIZE_BITS: u32 = 6;
pub const CONFIG_VTIMER_UPDATE_VOFFSET: u32 = 1;
pub const CONFIG_HAVE_FPU: u32 = 1;
pub const CONFIG_PADDR_USER_DEVICE_TOP: u64 = 1099511627776;
pub const CONFIG_ROOT_CNODE_SIZE_BITS: u32 = 19;
pub const CONFIG_TIMER_TICK_MS: u32 = 2;
pub const CONFIG_TIME_SLICE: u32 = 5;
pub const CONFIG_RETYPE_FAN_OUT_LIMIT: u32 = 16384;
pub const CONFIG_MAX_NUM_WORK_UNITS_PER_PREEMPTION: u32 = 100;
pub const CONFIG_RESET_CHUNK_BITS: u32 = 8;
pub const CONFIG_MAX_NUM_BOOTINFO_UNTYPED_CAPS: u32 = 230;
pub const CONFIG_FASTPATH: u32 = 1;
pub const CONFIG_NUM_DOMAINS: u32 = 1;
pub const CONFIG_NUM_PRIORITIES: u32 = 256;
pub const CONFIG_MAX_NUM_NODES: u32 = 1;
pub const CONFIG_KERNEL_STACK_BITS: u32 = 12;
pub const CONFIG_FPU_MAX_RESTORES_SINCE_SWITCH: u32 = 64;
pub const CONFIG_DEBUG_BUILD: u32 = 1;
pub const CONFIG_PRINTING: u32 = 1;
pub const CONFIG_NO_BENCHMARKS: u32 = 1;
pub const CONFIG_MAX_NUM_TRACE_POINTS: u32 = 0;
pub const CONFIG_IRQ_REPORTING: u32 = 1;
pub const CONFIG_COLOUR_PRINTING: u32 = 1;
pub const CONFIG_USER_STACK_TRACE_LENGTH: u32 = 16;
pub const CONFIG_KERNEL_OPT_LEVEL_O2: u32 = 1;
pub const CONFIG_KERNEL_OPTIMISATION_CLONE_FUNCTIONS: u32 = 1;
pub const CONFIG_LIB_SEL4_PUBLIC_SYMBOLS: u32 = 1;
pub const CONFIG_LIB_SEL4_PRINT_INVOCATION_ERRORS: u32 = 0;
pub const seL4_True: u32 = 1;
pub const seL4_False: u32 = 0;
pub const seL4_DataFault: u32 = 0;
pub const seL4_InstructionFault: u32 = 1;
pub const seL4_PageBits: u32 = 12;
pub const seL4_LargePageBits: u32 = 21;
pub const seL4_HugePageBits: u32 = 30;
pub const seL4_SlotBits: u32 = 5;
pub const seL4_TCBBits: u32 = 11;
pub const seL4_EndpointBits: u32 = 4;
pub const seL4_NotificationBits: u32 = 5;
pub const seL4_PageTableBits: u32 = 12;
pub const seL4_PageTableEntryBits: u32 = 3;
pub const seL4_PageTableIndexBits: u32 = 9;
pub const seL4_PageDirBits: u32 = 12;
pub const seL4_PageDirEntryBits: u32 = 3;
pub const seL4_PageDirIndexBits: u32 = 9;
pub const seL4_NumASIDPoolsBits: u32 = 7;
pub const seL4_ASIDPoolBits: u32 = 12;
pub const seL4_ASIDPoolIndexBits: u32 = 9;
pub const seL4_IOPageTableBits: u32 = 12;
pub const seL4_WordSizeBits: u32 = 3;
pub const seL4_PUDEntryBits: u32 = 3;
pub const seL4_PGDBits: u32 = 0;
pub const seL4_PGDEntryBits: u32 = 0;
pub const seL4_PGDIndexBits: u32 = 0;
pub const seL4_PUDBits: u32 = 13;
pub const seL4_PUDIndexBits: u32 = 10;
pub const seL4_VSpaceBits: u32 = 13;
pub const seL4_VSpaceIndexBits: u32 = 10;
pub const seL4_ARM_VCPUBits: u32 = 12;
pub const seL4_VCPUBits: u32 = 12;
pub const seL4_MinUntypedBits: u32 = 4;
pub const seL4_MaxUntypedBits: u32 = 47;
pub const seL4_FastMessageRegisters: u32 = 4;
pub const seL4_IPCBufferSizeBits: u32 = 10;
pub const seL4_UserTop: u64 = 1099511627775;
pub const seL4_ARM_IOPageTableObject: u32 = 65535;
pub const seL4_CapRightsBits: u32 = 4;
pub const seL4_GuardSizeBits: u32 = 6;
pub const seL4_GuardBits: u32 = 58;
pub const seL4_BadgeBits: u32 = 64;
pub const seL4_UntypedRetypeMaxObjects: u32 = 16384;
pub const seL4_NilData: u32 = 0;
pub const LIBSEL4_MCS_REPLY: u32 = 0;
pub type seL4_Bool = seL4_Int8;
pub const seL4_UnknownSyscall_Msg_seL4_UnknownSyscall_X0: seL4_UnknownSyscall_Msg = 0;
pub const seL4_UnknownSyscall_Msg_seL4_UnknownSyscall_X1: seL4_UnknownSyscall_Msg = 1;
pub const seL4_UnknownSyscall_Msg_seL4_UnknownSyscall_X2: seL4_UnknownSyscall_Msg = 2;
pub const seL4_UnknownSyscall_Msg_seL4_UnknownSyscall_X3: seL4_UnknownSyscall_Msg = 3;
pub const seL4_UnknownSyscall_Msg_seL4_UnknownSyscall_X4: seL4_UnknownSyscall_Msg = 4;
pub const seL4_UnknownSyscall_Msg_seL4_UnknownSyscall_X5: seL4_UnknownSyscall_Msg = 5;
pub const seL4_UnknownSyscall_Msg_seL4_UnknownSyscall_X6: seL4_UnknownSyscall_Msg = 6;
pub const seL4_UnknownSyscall_Msg_seL4_UnknownSyscall_X7: seL4_UnknownSyscall_Msg = 7;
pub const seL4_UnknownSyscall_Msg_seL4_UnknownSyscall_FaultIP: seL4_UnknownSyscall_Msg = 8;
pub const seL4_UnknownSyscall_Msg_seL4_UnknownSyscall_SP: seL4_UnknownSyscall_Msg = 9;
pub const seL4_UnknownSyscall_Msg_seL4_UnknownSyscall_LR: seL4_UnknownSyscall_Msg = 10;
pub const seL4_UnknownSyscall_Msg_seL4_UnknownSyscall_SPSR: seL4_UnknownSyscall_Msg = 11;
pub const seL4_UnknownSyscall_Msg_seL4_UnknownSyscall_Syscall: seL4_UnknownSyscall_Msg = 12;
pub const seL4_UnknownSyscall_Msg_seL4_UnknownSyscall_Length: seL4_UnknownSyscall_Msg = 13;
pub const seL4_UnknownSyscall_Msg__enum_pad_seL4_UnknownSyscall_Msg: seL4_UnknownSyscall_Msg =
    9223372036854775807;
pub type seL4_UnknownSyscall_Msg = u64;
pub const seL4_UserException_Msg_seL4_UserException_FaultIP: seL4_UserException_Msg = 0;
pub const seL4_UserException_Msg_seL4_UserException_SP: seL4_UserException_Msg = 1;
pub const seL4_UserException_Msg_seL4_UserException_SPSR: seL4_UserException_Msg = 2;
pub const seL4_UserException_Msg_seL4_UserException_Number: seL4_UserException_Msg = 3;
pub const seL4_UserException_Msg_seL4_UserException_Code: seL4_UserException_Msg = 4;
pub const seL4_UserException_Msg_seL4_UserException_Length: seL4_UserException_Msg = 5;
pub const seL4_UserException_Msg__enum_pad_seL4_UserException_Msg: seL4_UserException_Msg =
    9223372036854775807;
pub type seL4_UserException_Msg = u64;
pub const seL4_VMFault_Msg_seL4_VMFault_IP: seL4_VMFault_Msg = 0;
pub const seL4_VMFault_Msg_seL4_VMFault_Addr: seL4_VMFault_Msg = 1;
pub const seL4_VMFault_Msg_seL4_VMFault_PrefetchFault: seL4_VMFault_Msg = 2;
pub const seL4_VMFault_Msg_seL4_VMFault_FSR: seL4_VMFault_Msg = 3;
pub const seL4_VMFault_Msg_seL4_VMFault_Length: seL4_VMFault_Msg = 4;
pub const seL4_VMFault_Msg__enum_pad_seL4_VMFault_Msg: seL4_VMFault_Msg = 9223372036854775807;
pub type seL4_VMFault_Msg = u64;
pub const seL4_VGICMaintenance_Msg_seL4_VGICMaintenance_IDX: seL4_VGICMaintenance_Msg = 0;
pub const seL4_VGICMaintenance_Msg_seL4_VGICMaintenance_Length: seL4_VGICMaintenance_Msg = 1;
pub const seL4_VGICMaintenance_Msg__enum_pad_seL4_VGICMaintenance_Msg: seL4_VGICMaintenance_Msg =
    9223372036854775807;
pub type seL4_VGICMaintenance_Msg = u64;
pub const seL4_VPPIEvent_Msg_seL4_VPPIEvent_IRQ: seL4_VPPIEvent_Msg = 0;
pub const seL4_VPPIEvent_Msg__enum_pad_seL4_VPPIEvent_Msg: seL4_VPPIEvent_Msg = 9223372036854775807;
pub type seL4_VPPIEvent_Msg = u64;
pub const seL4_VCPUFault_Msg_seL4_VCPUFault_HSR: seL4_VCPUFault_Msg = 0;
pub const seL4_VCPUFault_Msg_seL4_VCPUFault_Length: seL4_VCPUFault_Msg = 1;
pub const seL4_VCPUFault_Msg__enum_pad_seL4_VCPUFault_Msg: seL4_VCPUFault_Msg = 9223372036854775807;
pub type seL4_VCPUFault_Msg = u64;
pub const seL4_VCPUReg_seL4_VCPUReg_SCTLR: seL4_VCPUReg = 0;
pub const seL4_VCPUReg_seL4_VCPUReg_TTBR0: seL4_VCPUReg = 1;
pub const seL4_VCPUReg_seL4_VCPUReg_TTBR1: seL4_VCPUReg = 2;
pub const seL4_VCPUReg_seL4_VCPUReg_TCR: seL4_VCPUReg = 3;
pub const seL4_VCPUReg_seL4_VCPUReg_MAIR: seL4_VCPUReg = 4;
pub const seL4_VCPUReg_seL4_VCPUReg_AMAIR: seL4_VCPUReg = 5;
pub const seL4_VCPUReg_seL4_VCPUReg_CIDR: seL4_VCPUReg = 6;
pub const seL4_VCPUReg_seL4_VCPUReg_ACTLR: seL4_VCPUReg = 7;
pub const seL4_VCPUReg_seL4_VCPUReg_CPACR: seL4_VCPUReg = 8;
pub const seL4_VCPUReg_seL4_VCPUReg_AFSR0: seL4_VCPUReg = 9;
pub const seL4_VCPUReg_seL4_VCPUReg_AFSR1: seL4_VCPUReg = 10;
pub const seL4_VCPUReg_seL4_VCPUReg_ESR: seL4_VCPUReg = 11;
pub const seL4_VCPUReg_seL4_VCPUReg_FAR: seL4_VCPUReg = 12;
pub const seL4_VCPUReg_seL4_VCPUReg_ISR: seL4_VCPUReg = 13;
pub const seL4_VCPUReg_seL4_VCPUReg_VBAR: seL4_VCPUReg = 14;
pub const seL4_VCPUReg_seL4_VCPUReg_TPIDR_EL1: seL4_VCPUReg = 15;
pub const seL4_VCPUReg_seL4_VCPUReg_SP_EL1: seL4_VCPUReg = 16;
pub const seL4_VCPUReg_seL4_VCPUReg_ELR_EL1: seL4_VCPUReg = 17;
pub const seL4_VCPUReg_seL4_VCPUReg_SPSR_EL1: seL4_VCPUReg = 18;
pub const seL4_VCPUReg_seL4_VCPUReg_CNTV_CTL: seL4_VCPUReg = 19;
pub const seL4_VCPUReg_seL4_VCPUReg_CNTV_CVAL: seL4_VCPUReg = 20;
pub const seL4_VCPUReg_seL4_VCPUReg_CNTVOFF: seL4_VCPUReg = 21;
pub const seL4_VCPUReg_seL4_VCPUReg_CNTKCTL_EL1: seL4_VCPUReg = 22;
pub const seL4_VCPUReg_seL4_VCPUReg_Num: seL4_VCPUReg = 23;
pub type seL4_VCPUReg = u32;
pub type seL4_ARM_PageUpperDirectory = seL4_CPtr;
pub type seL4_ARM_PageGlobalDirectory = seL4_CPtr;
pub type seL4_ARM_VSpace = seL4_CPtr;
#[repr(C)]
pub struct seL4_UserContext_ {
    pub pc: seL4_Word,
    pub sp: seL4_Word,
    pub spsr: seL4_Word,
    pub x0: seL4_Word,
    pub x1: seL4_Word,
    pub x2: seL4_Word,
    pub x3: seL4_Word,
    pub x4: seL4_Word,
    pub x5: seL4_Word,
    pub x6: seL4_Word,
    pub x7: seL4_Word,
    pub x8: seL4_Word,
    pub x16: seL4_Word,
    pub x17: seL4_Word,
    pub x18: seL4_Word,
    pub x29: seL4_Word,
    pub x30: seL4_Word,
    pub x9: seL4_Word,
    pub x10: seL4_Word,
    pub x11: seL4_Word,
    pub x12: seL4_Word,
    pub x13: seL4_Word,
    pub x14: seL4_Word,
    pub x15: seL4_Word,
    pub x19: seL4_Word,
    pub x20: seL4_Word,
    pub x21: seL4_Word,
    pub x22: seL4_Word,
    pub x23: seL4_Word,
    pub x24: seL4_Word,
    pub x25: seL4_Word,
    pub x26: seL4_Word,
    pub x27: seL4_Word,
    pub x28: seL4_Word,
    pub tpidr_el0: seL4_Word,
    pub tpidrro_el0: seL4_Word,
}
#[test]
fn bindgen_test_layout_seL4_UserContext_() {
    assert_eq!(
        ::core::mem::size_of::<seL4_UserContext_>(),
        288usize,
        concat!("Size of: ", stringify!(seL4_UserContext_))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_UserContext_>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_UserContext_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).pc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).sp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).spsr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(spsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x0 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x3 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x4 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x5 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x6 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x7 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x8 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x16 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x17 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x17)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x18 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x18)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x29 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x29)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x30 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x30)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x9 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x10 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x10)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x11 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x11)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x12 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x12)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x13 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x13)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x14 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x14)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x15 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x15)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x19 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x19)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x20 as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x20)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x21 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x21)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x22 as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x22)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x23 as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x23)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x24 as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x24)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x25 as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x25)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x26 as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x26)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x27 as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x27)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).x28 as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(x28)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).tpidr_el0 as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(tpidr_el0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UserContext_>())).tpidrro_el0 as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UserContext_),
            "::",
            stringify!(tpidrro_el0)
        )
    );
}
pub type seL4_UserContext = seL4_UserContext_;
pub type seL4_ARM_Page = seL4_CPtr;
pub type seL4_ARM_PageTable = seL4_CPtr;
pub type seL4_ARM_PageDirectory = seL4_CPtr;
pub type seL4_ARM_ASIDControl = seL4_CPtr;
pub type seL4_ARM_ASIDPool = seL4_CPtr;
pub type seL4_ARM_VCPU = seL4_CPtr;
pub type seL4_ARM_IOSpace = seL4_CPtr;
pub type seL4_ARM_IOPageTable = seL4_CPtr;
pub type seL4_ARM_SIDControl = seL4_CPtr;
pub type seL4_ARM_SID = seL4_CPtr;
pub type seL4_ARM_CBControl = seL4_CPtr;
pub type seL4_ARM_CB = seL4_CPtr;
pub const seL4_ARM_VMAttributes_seL4_ARM_PageCacheable: seL4_ARM_VMAttributes = 1;
pub const seL4_ARM_VMAttributes_seL4_ARM_ParityEnabled: seL4_ARM_VMAttributes = 2;
pub const seL4_ARM_VMAttributes_seL4_ARM_Default_VMAttributes: seL4_ARM_VMAttributes = 3;
pub const seL4_ARM_VMAttributes_seL4_ARM_ExecuteNever: seL4_ARM_VMAttributes = 4;
pub const seL4_ARM_VMAttributes__enum_pad_seL4_ARM_VMAttributes: seL4_ARM_VMAttributes =
    9223372036854775807;
pub type seL4_ARM_VMAttributes = u64;
pub const seL4_ARM_CacheType_seL4_ARM_CacheI: seL4_ARM_CacheType = 1;
pub const seL4_ARM_CacheType_seL4_ARM_CacheD: seL4_ARM_CacheType = 2;
pub const seL4_ARM_CacheType_seL4_ARM_CacheID: seL4_ARM_CacheType = 3;
pub const seL4_ARM_CacheType__enum_pad_seL4_ARM_CacheType: seL4_ARM_CacheType = 9223372036854775807;
pub type seL4_ARM_CacheType = u64;
extern "C" {
    #[doc = " Hidden function, use the macros seL4_Fail or seL4_Assert."]
    pub fn __assert_fail(
        str: *const ctypes::c_char,
        file: *const ctypes::c_char,
        line: ctypes::c_int,
        function: *const ctypes::c_char,
    );
}
#[repr(C)]
pub struct seL4_Fault {
    pub words: [seL4_Uint64; 14usize],
}
#[test]
fn bindgen_test_layout_seL4_Fault() {
    assert_eq!(
        ::core::mem::size_of::<seL4_Fault>(),
        112usize,
        concat!("Size of: ", stringify!(seL4_Fault))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_Fault>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_Fault))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_Fault>())).words as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_Fault),
            "::",
            stringify!(words)
        )
    );
}
pub type seL4_Fault_t = seL4_Fault;
pub const seL4_Fault_tag_seL4_Fault_NullFault: seL4_Fault_tag = 0;
pub const seL4_Fault_tag_seL4_Fault_CapFault: seL4_Fault_tag = 1;
pub const seL4_Fault_tag_seL4_Fault_UnknownSyscall: seL4_Fault_tag = 2;
pub const seL4_Fault_tag_seL4_Fault_UserException: seL4_Fault_tag = 3;
pub const seL4_Fault_tag_seL4_Fault_VMFault: seL4_Fault_tag = 5;
pub const seL4_Fault_tag_seL4_Fault_VGICMaintenance: seL4_Fault_tag = 6;
pub const seL4_Fault_tag_seL4_Fault_VCPUFault: seL4_Fault_tag = 7;
pub const seL4_Fault_tag_seL4_Fault_VPPIEvent: seL4_Fault_tag = 8;
pub type seL4_Fault_tag = u32;
pub use self::seL4_Fault_tag as seL4_Fault_tag_t;
extern "C" {
    pub fn seL4_Fault_get_seL4_FaultType(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_seL4_FaultType_equals(
        seL4_Fault: seL4_Fault_t,
        seL4_Fault_type_tag: seL4_Uint64,
    ) -> ctypes::c_int;
}
extern "C" {
    pub fn seL4_Fault_ptr_get_seL4_FaultType(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_NullFault_new() -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_NullFault_ptr_new(seL4_Fault_ptr: *mut seL4_Fault_t);
}
extern "C" {
    pub fn seL4_Fault_CapFault_new(
        IP: seL4_Uint64,
        Addr: seL4_Uint64,
        InRecvPhase: seL4_Uint64,
        LookupFailureType: seL4_Uint64,
        MR4: seL4_Uint64,
        MR5: seL4_Uint64,
        MR6: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_CapFault_ptr_new(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        IP: seL4_Uint64,
        Addr: seL4_Uint64,
        InRecvPhase: seL4_Uint64,
        LookupFailureType: seL4_Uint64,
        MR4: seL4_Uint64,
        MR5: seL4_Uint64,
        MR6: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_CapFault_get_IP(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_CapFault_set_IP(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_CapFault_ptr_get_IP(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_CapFault_ptr_set_IP(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64);
}
extern "C" {
    pub fn seL4_Fault_CapFault_get_Addr(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_CapFault_set_Addr(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64)
        -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_CapFault_ptr_get_Addr(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_CapFault_ptr_set_Addr(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64);
}
extern "C" {
    pub fn seL4_Fault_CapFault_get_InRecvPhase(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_CapFault_set_InRecvPhase(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_CapFault_ptr_get_InRecvPhase(
        seL4_Fault_ptr: *mut seL4_Fault_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_CapFault_ptr_set_InRecvPhase(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_CapFault_get_LookupFailureType(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_CapFault_set_LookupFailureType(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_CapFault_ptr_get_LookupFailureType(
        seL4_Fault_ptr: *mut seL4_Fault_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_CapFault_ptr_set_LookupFailureType(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_CapFault_get_MR4(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_CapFault_set_MR4(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_CapFault_ptr_get_MR4(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_CapFault_ptr_set_MR4(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64);
}
extern "C" {
    pub fn seL4_Fault_CapFault_get_MR5(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_CapFault_set_MR5(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_CapFault_ptr_get_MR5(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_CapFault_ptr_set_MR5(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64);
}
extern "C" {
    pub fn seL4_Fault_CapFault_get_MR6(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_CapFault_set_MR6(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_CapFault_ptr_get_MR6(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_CapFault_ptr_set_MR6(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64);
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_new(
        X0: seL4_Uint64,
        X1: seL4_Uint64,
        X2: seL4_Uint64,
        X3: seL4_Uint64,
        X4: seL4_Uint64,
        X5: seL4_Uint64,
        X6: seL4_Uint64,
        X7: seL4_Uint64,
        FaultIP: seL4_Uint64,
        SP: seL4_Uint64,
        LR: seL4_Uint64,
        SPSR: seL4_Uint64,
        Syscall: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_new(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        X0: seL4_Uint64,
        X1: seL4_Uint64,
        X2: seL4_Uint64,
        X3: seL4_Uint64,
        X4: seL4_Uint64,
        X5: seL4_Uint64,
        X6: seL4_Uint64,
        X7: seL4_Uint64,
        FaultIP: seL4_Uint64,
        SP: seL4_Uint64,
        LR: seL4_Uint64,
        SPSR: seL4_Uint64,
        Syscall: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_get_X0(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_set_X0(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_get_X0(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_set_X0(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_get_X1(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_set_X1(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_get_X1(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_set_X1(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_get_X2(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_set_X2(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_get_X2(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_set_X2(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_get_X3(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_set_X3(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_get_X3(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_set_X3(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_get_X4(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_set_X4(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_get_X4(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_set_X4(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_get_X5(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_set_X5(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_get_X5(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_set_X5(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_get_X6(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_set_X6(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_get_X6(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_set_X6(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_get_X7(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_set_X7(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_get_X7(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_set_X7(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_get_FaultIP(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_set_FaultIP(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_get_FaultIP(
        seL4_Fault_ptr: *mut seL4_Fault_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_set_FaultIP(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_get_SP(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_set_SP(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_get_SP(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_set_SP(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_get_LR(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_set_LR(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_get_LR(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_set_LR(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_get_SPSR(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_set_SPSR(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_get_SPSR(seL4_Fault_ptr: *mut seL4_Fault_t)
        -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_set_SPSR(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_get_Syscall(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_set_Syscall(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_get_Syscall(
        seL4_Fault_ptr: *mut seL4_Fault_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UnknownSyscall_ptr_set_Syscall(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UserException_new(
        FaultIP: seL4_Uint64,
        Stack: seL4_Uint64,
        SPSR: seL4_Uint64,
        Number: seL4_Uint64,
        Code: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UserException_ptr_new(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        FaultIP: seL4_Uint64,
        Stack: seL4_Uint64,
        SPSR: seL4_Uint64,
        Number: seL4_Uint64,
        Code: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UserException_get_FaultIP(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UserException_set_FaultIP(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UserException_ptr_get_FaultIP(
        seL4_Fault_ptr: *mut seL4_Fault_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UserException_ptr_set_FaultIP(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UserException_get_Stack(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UserException_set_Stack(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UserException_ptr_get_Stack(seL4_Fault_ptr: *mut seL4_Fault_t)
        -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UserException_ptr_set_Stack(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UserException_get_SPSR(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UserException_set_SPSR(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UserException_ptr_get_SPSR(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UserException_ptr_set_SPSR(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UserException_get_Number(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UserException_set_Number(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UserException_ptr_get_Number(
        seL4_Fault_ptr: *mut seL4_Fault_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UserException_ptr_set_Number(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_UserException_get_Code(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UserException_set_Code(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_UserException_ptr_get_Code(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_UserException_ptr_set_Code(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_VMFault_new(
        IP: seL4_Uint64,
        Addr: seL4_Uint64,
        PrefetchFault: seL4_Uint64,
        FSR: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_VMFault_ptr_new(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        IP: seL4_Uint64,
        Addr: seL4_Uint64,
        PrefetchFault: seL4_Uint64,
        FSR: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_VMFault_get_IP(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_VMFault_set_IP(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_VMFault_ptr_get_IP(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_VMFault_ptr_set_IP(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64);
}
extern "C" {
    pub fn seL4_Fault_VMFault_get_Addr(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_VMFault_set_Addr(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_VMFault_ptr_get_Addr(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_VMFault_ptr_set_Addr(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64);
}
extern "C" {
    pub fn seL4_Fault_VMFault_get_PrefetchFault(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_VMFault_set_PrefetchFault(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_VMFault_ptr_get_PrefetchFault(
        seL4_Fault_ptr: *mut seL4_Fault_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_VMFault_ptr_set_PrefetchFault(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_VMFault_get_FSR(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_VMFault_set_FSR(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_VMFault_ptr_get_FSR(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_VMFault_ptr_set_FSR(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64);
}
extern "C" {
    pub fn seL4_Fault_VGICMaintenance_new(IDX: seL4_Uint64) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_VGICMaintenance_ptr_new(seL4_Fault_ptr: *mut seL4_Fault_t, IDX: seL4_Uint64);
}
extern "C" {
    pub fn seL4_Fault_VGICMaintenance_get_IDX(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_VGICMaintenance_set_IDX(
        seL4_Fault: seL4_Fault_t,
        v64: seL4_Uint64,
    ) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_VGICMaintenance_ptr_get_IDX(seL4_Fault_ptr: *mut seL4_Fault_t)
        -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_VGICMaintenance_ptr_set_IDX(
        seL4_Fault_ptr: *mut seL4_Fault_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_Fault_VCPUFault_new(HSR: seL4_Uint64) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_VCPUFault_ptr_new(seL4_Fault_ptr: *mut seL4_Fault_t, HSR: seL4_Uint64);
}
extern "C" {
    pub fn seL4_Fault_VCPUFault_get_HSR(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_VCPUFault_set_HSR(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64)
        -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_VCPUFault_ptr_get_HSR(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_VCPUFault_ptr_set_HSR(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64);
}
extern "C" {
    pub fn seL4_Fault_VPPIEvent_new(irq: seL4_Uint64) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_VPPIEvent_ptr_new(seL4_Fault_ptr: *mut seL4_Fault_t, irq: seL4_Uint64);
}
extern "C" {
    pub fn seL4_Fault_VPPIEvent_get_irq(seL4_Fault: seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_VPPIEvent_set_irq(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64)
        -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_Fault_VPPIEvent_ptr_get_irq(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_Fault_VPPIEvent_ptr_set_irq(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64);
}
pub const seL4_Syscall_ID_seL4_SysCall: seL4_Syscall_ID = -1;
pub const seL4_Syscall_ID_seL4_SysReplyRecv: seL4_Syscall_ID = -2;
pub const seL4_Syscall_ID_seL4_SysSend: seL4_Syscall_ID = -3;
pub const seL4_Syscall_ID_seL4_SysNBSend: seL4_Syscall_ID = -4;
pub const seL4_Syscall_ID_seL4_SysRecv: seL4_Syscall_ID = -5;
pub const seL4_Syscall_ID_seL4_SysReply: seL4_Syscall_ID = -6;
pub const seL4_Syscall_ID_seL4_SysYield: seL4_Syscall_ID = -7;
pub const seL4_Syscall_ID_seL4_SysNBRecv: seL4_Syscall_ID = -8;
pub const seL4_Syscall_ID_seL4_SysDebugPutChar: seL4_Syscall_ID = -9;
pub const seL4_Syscall_ID_seL4_SysDebugDumpScheduler: seL4_Syscall_ID = -10;
pub const seL4_Syscall_ID_seL4_SysDebugHalt: seL4_Syscall_ID = -11;
pub const seL4_Syscall_ID_seL4_SysDebugCapIdentify: seL4_Syscall_ID = -12;
pub const seL4_Syscall_ID_seL4_SysDebugSnapshot: seL4_Syscall_ID = -13;
pub const seL4_Syscall_ID_seL4_SysDebugNameThread: seL4_Syscall_ID = -14;
pub const seL4_Syscall_ID__enum_pad_seL4_Syscall_ID: seL4_Syscall_ID = 9223372036854775807;
pub type seL4_Syscall_ID = i64;
pub const api_object_seL4_UntypedObject: api_object = 0;
pub const api_object_seL4_TCBObject: api_object = 1;
pub const api_object_seL4_EndpointObject: api_object = 2;
pub const api_object_seL4_NotificationObject: api_object = 3;
pub const api_object_seL4_CapTableObject: api_object = 4;
pub const api_object_seL4_NonArchObjectTypeCount: api_object = 5;
pub type api_object = u32;
pub use self::api_object as seL4_ObjectType;
extern "C" {
    pub static seL4_AsyncEndpointObject: seL4_ObjectType;
}
pub type api_object_t = seL4_Word;
pub const _mode_object_seL4_ARM_HugePageObject: _mode_object = 5;
pub const _mode_object_seL4_ARM_PageUpperDirectoryObject: _mode_object = 6;
pub const _mode_object_seL4_ARM_PageGlobalDirectoryObject: _mode_object = 7;
pub const _mode_object_seL4_ModeObjectTypeCount: _mode_object = 8;
pub type _mode_object = u32;
pub use self::_mode_object as seL4_ModeObjectType;
pub const _object_seL4_ARM_SmallPageObject: _object = 8;
pub const _object_seL4_ARM_LargePageObject: _object = 9;
pub const _object_seL4_ARM_PageTableObject: _object = 10;
pub const _object_seL4_ARM_PageDirectoryObject: _object = 11;
pub const _object_seL4_ARM_VCPUObject: _object = 12;
pub const _object_seL4_ObjectTypeCount: _object = 13;
pub type _object = u32;
pub use self::_object as seL4_ArchObjectType;
pub type object_t = seL4_Word;
pub const seL4_Error_seL4_NoError: seL4_Error = 0;
pub const seL4_Error_seL4_InvalidArgument: seL4_Error = 1;
pub const seL4_Error_seL4_InvalidCapability: seL4_Error = 2;
pub const seL4_Error_seL4_IllegalOperation: seL4_Error = 3;
pub const seL4_Error_seL4_RangeError: seL4_Error = 4;
pub const seL4_Error_seL4_AlignmentError: seL4_Error = 5;
pub const seL4_Error_seL4_FailedLookup: seL4_Error = 6;
pub const seL4_Error_seL4_TruncatedMessage: seL4_Error = 7;
pub const seL4_Error_seL4_DeleteFirst: seL4_Error = 8;
pub const seL4_Error_seL4_RevokeFirst: seL4_Error = 9;
pub const seL4_Error_seL4_NotEnoughMemory: seL4_Error = 10;
pub const seL4_Error_seL4_NumErrors: seL4_Error = 11;
pub type seL4_Error = u32;
pub const priorityConstants_seL4_InvalidPrio: priorityConstants = -1;
pub const priorityConstants_seL4_MinPrio: priorityConstants = 0;
pub const priorityConstants_seL4_MaxPrio: priorityConstants = 255;
pub type priorityConstants = i32;
pub const seL4_MsgLimits_seL4_MsgLengthBits: seL4_MsgLimits = 7;
pub const seL4_MsgLimits_seL4_MsgExtraCapBits: seL4_MsgLimits = 2;
pub type seL4_MsgLimits = u32;
pub const seL4_MsgMaxLength: _bindgen_ty_1 = 120;
pub type _bindgen_ty_1 = u32;
pub const seL4_LookupFailureType_seL4_NoFailure: seL4_LookupFailureType = 0;
pub const seL4_LookupFailureType_seL4_InvalidRoot: seL4_LookupFailureType = 1;
pub const seL4_LookupFailureType_seL4_MissingCapability: seL4_LookupFailureType = 2;
pub const seL4_LookupFailureType_seL4_DepthMismatch: seL4_LookupFailureType = 3;
pub const seL4_LookupFailureType_seL4_GuardMismatch: seL4_LookupFailureType = 4;
pub const seL4_LookupFailureType__enum_pad_seL4_LookupFailureType: seL4_LookupFailureType =
    9223372036854775807;
pub type seL4_LookupFailureType = u64;
#[repr(C)]
pub struct seL4_CNode_CapData {
    pub words: [seL4_Uint64; 1usize],
}
#[test]
fn bindgen_test_layout_seL4_CNode_CapData() {
    assert_eq!(
        ::core::mem::size_of::<seL4_CNode_CapData>(),
        8usize,
        concat!("Size of: ", stringify!(seL4_CNode_CapData))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_CNode_CapData>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_CNode_CapData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_CNode_CapData>())).words as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_CNode_CapData),
            "::",
            stringify!(words)
        )
    );
}
pub type seL4_CNode_CapData_t = seL4_CNode_CapData;
extern "C" {
    pub fn seL4_CNode_CapData_new(
        guard: seL4_Uint64,
        guardSize: seL4_Uint64,
    ) -> seL4_CNode_CapData_t;
}
extern "C" {
    pub fn seL4_CNode_CapData_ptr_new(
        seL4_CNode_CapData_ptr: *mut seL4_CNode_CapData_t,
        guard: seL4_Uint64,
        guardSize: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_CNode_CapData_get_guard(seL4_CNode_CapData: seL4_CNode_CapData_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_CNode_CapData_set_guard(
        seL4_CNode_CapData: seL4_CNode_CapData_t,
        v64: seL4_Uint64,
    ) -> seL4_CNode_CapData_t;
}
extern "C" {
    pub fn seL4_CNode_CapData_ptr_get_guard(
        seL4_CNode_CapData_ptr: *mut seL4_CNode_CapData_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_CNode_CapData_ptr_set_guard(
        seL4_CNode_CapData_ptr: *mut seL4_CNode_CapData_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_CNode_CapData_get_guardSize(
        seL4_CNode_CapData: seL4_CNode_CapData_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_CNode_CapData_set_guardSize(
        seL4_CNode_CapData: seL4_CNode_CapData_t,
        v64: seL4_Uint64,
    ) -> seL4_CNode_CapData_t;
}
extern "C" {
    pub fn seL4_CNode_CapData_ptr_get_guardSize(
        seL4_CNode_CapData_ptr: *mut seL4_CNode_CapData_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_CNode_CapData_ptr_set_guardSize(
        seL4_CNode_CapData_ptr: *mut seL4_CNode_CapData_t,
        v64: seL4_Uint64,
    );
}
#[repr(C)]
pub struct seL4_CapRights {
    pub words: [seL4_Uint64; 1usize],
}
#[test]
fn bindgen_test_layout_seL4_CapRights() {
    assert_eq!(
        ::core::mem::size_of::<seL4_CapRights>(),
        8usize,
        concat!("Size of: ", stringify!(seL4_CapRights))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_CapRights>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_CapRights))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_CapRights>())).words as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_CapRights),
            "::",
            stringify!(words)
        )
    );
}
pub type seL4_CapRights_t = seL4_CapRights;
extern "C" {
    pub fn seL4_CapRights_new(
        capAllowGrantReply: seL4_Uint64,
        capAllowGrant: seL4_Uint64,
        capAllowRead: seL4_Uint64,
        capAllowWrite: seL4_Uint64,
    ) -> seL4_CapRights_t;
}
extern "C" {
    pub fn seL4_CapRights_ptr_new(
        seL4_CapRights_ptr: *mut seL4_CapRights_t,
        capAllowGrantReply: seL4_Uint64,
        capAllowGrant: seL4_Uint64,
        capAllowRead: seL4_Uint64,
        capAllowWrite: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_CapRights_get_capAllowGrantReply(seL4_CapRights: seL4_CapRights_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_CapRights_set_capAllowGrantReply(
        seL4_CapRights: seL4_CapRights_t,
        v64: seL4_Uint64,
    ) -> seL4_CapRights_t;
}
extern "C" {
    pub fn seL4_CapRights_ptr_get_capAllowGrantReply(
        seL4_CapRights_ptr: *mut seL4_CapRights_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_CapRights_ptr_set_capAllowGrantReply(
        seL4_CapRights_ptr: *mut seL4_CapRights_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_CapRights_get_capAllowGrant(seL4_CapRights: seL4_CapRights_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_CapRights_set_capAllowGrant(
        seL4_CapRights: seL4_CapRights_t,
        v64: seL4_Uint64,
    ) -> seL4_CapRights_t;
}
extern "C" {
    pub fn seL4_CapRights_ptr_get_capAllowGrant(
        seL4_CapRights_ptr: *mut seL4_CapRights_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_CapRights_ptr_set_capAllowGrant(
        seL4_CapRights_ptr: *mut seL4_CapRights_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_CapRights_get_capAllowRead(seL4_CapRights: seL4_CapRights_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_CapRights_set_capAllowRead(
        seL4_CapRights: seL4_CapRights_t,
        v64: seL4_Uint64,
    ) -> seL4_CapRights_t;
}
extern "C" {
    pub fn seL4_CapRights_ptr_get_capAllowRead(
        seL4_CapRights_ptr: *mut seL4_CapRights_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_CapRights_ptr_set_capAllowRead(
        seL4_CapRights_ptr: *mut seL4_CapRights_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_CapRights_get_capAllowWrite(seL4_CapRights: seL4_CapRights_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_CapRights_set_capAllowWrite(
        seL4_CapRights: seL4_CapRights_t,
        v64: seL4_Uint64,
    ) -> seL4_CapRights_t;
}
extern "C" {
    pub fn seL4_CapRights_ptr_get_capAllowWrite(
        seL4_CapRights_ptr: *mut seL4_CapRights_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_CapRights_ptr_set_capAllowWrite(
        seL4_CapRights_ptr: *mut seL4_CapRights_t,
        v64: seL4_Uint64,
    );
}
#[repr(C)]
pub struct seL4_MessageInfo {
    pub words: [seL4_Uint64; 1usize],
}
#[test]
fn bindgen_test_layout_seL4_MessageInfo() {
    assert_eq!(
        ::core::mem::size_of::<seL4_MessageInfo>(),
        8usize,
        concat!("Size of: ", stringify!(seL4_MessageInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_MessageInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_MessageInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_MessageInfo>())).words as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_MessageInfo),
            "::",
            stringify!(words)
        )
    );
}
pub type seL4_MessageInfo_t = seL4_MessageInfo;
extern "C" {
    pub fn seL4_MessageInfo_new(
        label: seL4_Uint64,
        capsUnwrapped: seL4_Uint64,
        extraCaps: seL4_Uint64,
        length: seL4_Uint64,
    ) -> seL4_MessageInfo_t;
}
extern "C" {
    pub fn seL4_MessageInfo_ptr_new(
        seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
        label: seL4_Uint64,
        capsUnwrapped: seL4_Uint64,
        extraCaps: seL4_Uint64,
        length: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_MessageInfo_get_label(seL4_MessageInfo: seL4_MessageInfo_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_MessageInfo_set_label(
        seL4_MessageInfo: seL4_MessageInfo_t,
        v64: seL4_Uint64,
    ) -> seL4_MessageInfo_t;
}
extern "C" {
    pub fn seL4_MessageInfo_ptr_get_label(
        seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_MessageInfo_ptr_set_label(
        seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_MessageInfo_get_capsUnwrapped(seL4_MessageInfo: seL4_MessageInfo_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_MessageInfo_set_capsUnwrapped(
        seL4_MessageInfo: seL4_MessageInfo_t,
        v64: seL4_Uint64,
    ) -> seL4_MessageInfo_t;
}
extern "C" {
    pub fn seL4_MessageInfo_ptr_get_capsUnwrapped(
        seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_MessageInfo_ptr_set_capsUnwrapped(
        seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_MessageInfo_get_extraCaps(seL4_MessageInfo: seL4_MessageInfo_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_MessageInfo_set_extraCaps(
        seL4_MessageInfo: seL4_MessageInfo_t,
        v64: seL4_Uint64,
    ) -> seL4_MessageInfo_t;
}
extern "C" {
    pub fn seL4_MessageInfo_ptr_get_extraCaps(
        seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_MessageInfo_ptr_set_extraCaps(
        seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
        v64: seL4_Uint64,
    );
}
extern "C" {
    pub fn seL4_MessageInfo_get_length(seL4_MessageInfo: seL4_MessageInfo_t) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_MessageInfo_set_length(
        seL4_MessageInfo: seL4_MessageInfo_t,
        v64: seL4_Uint64,
    ) -> seL4_MessageInfo_t;
}
extern "C" {
    pub fn seL4_MessageInfo_ptr_get_length(
        seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
    ) -> seL4_Uint64;
}
extern "C" {
    pub fn seL4_MessageInfo_ptr_set_length(
        seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
        v64: seL4_Uint64,
    );
}
#[repr(C)]
pub struct seL4_IPCBuffer_ {
    pub tag: seL4_MessageInfo_t,
    pub msg: [seL4_Word; 120usize],
    pub userData: seL4_Word,
    pub caps_or_badges: [seL4_Word; 3usize],
    pub receiveCNode: seL4_CPtr,
    pub receiveIndex: seL4_CPtr,
    pub receiveDepth: seL4_Word,
}
#[test]
fn bindgen_test_layout_seL4_IPCBuffer_() {
    assert_eq!(
        ::core::mem::size_of::<seL4_IPCBuffer_>(),
        1024usize,
        concat!("Size of: ", stringify!(seL4_IPCBuffer_))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_IPCBuffer_>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_IPCBuffer_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_IPCBuffer_>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_IPCBuffer_),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_IPCBuffer_>())).msg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_IPCBuffer_),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_IPCBuffer_>())).userData as *const _ as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_IPCBuffer_),
            "::",
            stringify!(userData)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_IPCBuffer_>())).caps_or_badges as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_IPCBuffer_),
            "::",
            stringify!(caps_or_badges)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_IPCBuffer_>())).receiveCNode as *const _ as usize },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_IPCBuffer_),
            "::",
            stringify!(receiveCNode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_IPCBuffer_>())).receiveIndex as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_IPCBuffer_),
            "::",
            stringify!(receiveIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_IPCBuffer_>())).receiveDepth as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_IPCBuffer_),
            "::",
            stringify!(receiveDepth)
        )
    );
}
pub type seL4_IPCBuffer = seL4_IPCBuffer_;
pub const seL4_CapFault_Msg_seL4_CapFault_IP: seL4_CapFault_Msg = 0;
pub const seL4_CapFault_Msg_seL4_CapFault_Addr: seL4_CapFault_Msg = 1;
pub const seL4_CapFault_Msg_seL4_CapFault_InRecvPhase: seL4_CapFault_Msg = 2;
pub const seL4_CapFault_Msg_seL4_CapFault_LookupFailureType: seL4_CapFault_Msg = 3;
pub const seL4_CapFault_Msg_seL4_CapFault_BitsLeft: seL4_CapFault_Msg = 4;
pub const seL4_CapFault_Msg_seL4_CapFault_DepthMismatch_BitsFound: seL4_CapFault_Msg = 5;
pub const seL4_CapFault_Msg_seL4_CapFault_GuardMismatch_GuardFound: seL4_CapFault_Msg = 5;
pub const seL4_CapFault_Msg_seL4_CapFault_GuardMismatch_BitsFound: seL4_CapFault_Msg = 6;
pub const seL4_CapFault_Msg__enum_pad_seL4_CapFault_Msg: seL4_CapFault_Msg = 9223372036854775807;
pub type seL4_CapFault_Msg = u64;
pub type seL4_NodeId = seL4_Word;
pub type seL4_PAddr = seL4_Word;
pub type seL4_Domain = seL4_Word;
pub type seL4_CNode = seL4_CPtr;
pub type seL4_IRQHandler = seL4_CPtr;
pub type seL4_IRQControl = seL4_CPtr;
pub type seL4_TCB = seL4_CPtr;
pub type seL4_Untyped = seL4_CPtr;
pub type seL4_DomainSet = seL4_CPtr;
pub type seL4_SchedContext = seL4_CPtr;
pub type seL4_SchedControl = seL4_CPtr;
pub type seL4_Time = seL4_Uint64;
extern "C" {
    #[doc = " @xmlonly <manual name=\"Send\" label=\"sel4_send\"/> @endxmlonly"]
    #[doc = " @brief Send to a capability"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:sys_send\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] dest The capability to be invoked."]
    #[doc = " @param[in] msgInfo The messageinfo structure for the IPC."]
    pub fn seL4_Send(dest: seL4_CPtr, msgInfo: seL4_MessageInfo_t);
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Recv\" label=\"sel4_recv\"/> @endxmlonly"]
    #[doc = " @brief Block until a message is received on an endpoint"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:sys_recv\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] src The capability to be invoked."]
    #[doc = " @param[out] sender The address to write sender information to."]
    #[doc = "               The sender information is the badge of the"]
    #[doc = "               endpoint capability that was invoked by the"]
    #[doc = "               sender, or the notification word of the"]
    #[doc = "               notification object that was signalled."]
    #[doc = "               This parameter is ignored if `NULL`."]
    #[doc = ""]
    #[doc = " @return A `seL4_MessageInfo_t` structure"]
    #[doc = " @xmlonly"]
    #[doc = " <docref>as described in <autoref label=\"sec:messageinfo\"/></docref>"]
    #[doc = " @endxmlonly"]
    pub fn seL4_Recv(src: seL4_CPtr, sender: *mut seL4_Word) -> seL4_MessageInfo_t;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Call\" label=\"sel4_call\"/> @endxmlonly"]
    #[doc = " @brief  Call a capability"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:sys_call\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] dest The capability to be invoked."]
    #[doc = " @param[in] msgInfo The messageinfo structure for the IPC."]
    #[doc = ""]
    #[doc = " @return A `seL4_MessageInfo_t` structure"]
    #[doc = " @xmlonly"]
    #[doc = " <docref>as described in <autoref label=\"sec:messageinfo\"/></docref>"]
    #[doc = " @endxmlonly"]
    pub fn seL4_Call(dest: seL4_CPtr, msgInfo: seL4_MessageInfo_t) -> seL4_MessageInfo_t;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Reply\" label=\"sel4_reply\"/> @endxmlonly"]
    #[doc = " @brief Perform a send to a one-off reply capability stored when"]
    #[doc = "        the thread was last called. Does nothing if there is no"]
    #[doc = "        reply capability which can happen if the blocked thread"]
    #[doc = "        was unblocked via an operation such as destroying it."]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:sys_reply\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] msgInfo The messageinfo structure for the IPC."]
    pub fn seL4_Reply(msgInfo: seL4_MessageInfo_t);
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Non-Blocking Send\" label=\"sel4_nbsend\"/> @endxmlonly"]
    #[doc = " @brief Perform a non-blocking send to a capability"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:sys_nbsend\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] dest The capability to be invoked."]
    #[doc = " @param[in] msgInfo The messageinfo structure for the IPC."]
    pub fn seL4_NBSend(dest: seL4_CPtr, msgInfo: seL4_MessageInfo_t);
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Reply Recv\" label=\"sel4_replyrecv\"/> @endxmlonly"]
    #[doc = " @brief Perform a reply followed by a receive in one system call"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:sys_replyrecv\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] dest The capability to be invoked."]
    #[doc = " @param[in] msgInfo The messageinfo structure for the IPC."]
    #[doc = " @param[out] sender The address to write sender information to."]
    #[doc = "               The sender information is the badge of the"]
    #[doc = "               endpoint capability that was invoked by the"]
    #[doc = "               sender, or the notification word of the"]
    #[doc = "               notification object that was signalled."]
    #[doc = "               This parameter is ignored if `NULL`."]
    #[doc = ""]
    #[doc = " @return A `seL4_MessageInfo_t` structure"]
    #[doc = " @xmlonly"]
    #[doc = " <docref>as described in <autoref label=\"sec:messageinfo\"/></docref>"]
    #[doc = " @endxmlonly"]
    pub fn seL4_ReplyRecv(
        dest: seL4_CPtr,
        msgInfo: seL4_MessageInfo_t,
        sender: *mut seL4_Word,
    ) -> seL4_MessageInfo_t;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"NBRecv\" label=\"sel4_nbrecv\"/> @endxmlonly"]
    #[doc = " @brief Receive a message from an endpoint but do not block"]
    #[doc = "        in the case that no messages are pending"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:sys_nbrecv\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] src The capability to be invoked."]
    #[doc = " @param[out] sender The address to write sender information to."]
    #[doc = "                    The sender information is the badge of the"]
    #[doc = "                    endpoint capability that was invoked by the"]
    #[doc = "                    sender, or the notification word of the"]
    #[doc = "                    notification object that was signalled."]
    #[doc = "                    This parameter is ignored if `NULL`."]
    #[doc = ""]
    #[doc = " @return A `seL4_MessageInfo_t` structure"]
    #[doc = " @xmlonly"]
    #[doc = " <docref>as described in <autoref label=\"sec:messageinfo\"/></docref>"]
    #[doc = " @endxmlonly"]
    pub fn seL4_NBRecv(src: seL4_CPtr, sender: *mut seL4_Word) -> seL4_MessageInfo_t;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Yield\" label=\"sel4_yield\"/> @endxmlonly"]
    #[doc = " @brief Donate the remaining timeslice to a thread of the same priority"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:sys_yield\"/></docref>"]
    #[doc = " @endxmlonly"]
    pub fn seL4_Yield();
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Signal\" label=\"sel4_signal\"/> @endxmlonly"]
    #[doc = " @brief Signal a notification"]
    #[doc = ""]
    #[doc = " This is not a proper system call known by the kernel. Rather, it is a"]
    #[doc = " convenience wrapper which calls seL4_Send()."]
    #[doc = " It is useful for signalling a notification."]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See the description of <nameref name=\"seL4_Send\"/> in <autoref label=\"sec:sys_send\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] dest The capability to be invoked."]
    pub fn seL4_Signal(dest: seL4_CPtr);
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Wait\" label=\"sel4_wait\"/> @endxmlonly"]
    #[doc = " @brief Perform a receive on a notification object"]
    #[doc = ""]
    #[doc = " This is not a proper system call known by the kernel. Rather, it is a"]
    #[doc = " convenience wrapper which calls seL4_Recv()."]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See the description of <nameref name=\"seL4_Recv\"/> in <autoref label=\"sec:sys_recv\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] src The capability to be invoked."]
    #[doc = " @param[out] sender The address to write sender information to."]
    #[doc = "               The sender information is the badge of the"]
    #[doc = "               endpoint capability that was invoked by the"]
    #[doc = "               sender, or the notification word of the"]
    #[doc = "               notification object that was signalled."]
    #[doc = "               This parameter is ignored if `NULL`."]
    pub fn seL4_Wait(src: seL4_CPtr, sender: *mut seL4_Word);
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Poll\" label=\"sel4_poll\"/> @endxmlonly"]
    #[doc = " @brief Perform a non-blocking recv on a notification object"]
    #[doc = ""]
    #[doc = " This is not a proper system call known by the kernel. Rather, it is a"]
    #[doc = " convenience wrapper which calls seL4_NBRecv()."]
    #[doc = " It is useful for doing a non-blocking wait on a notification."]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See the description of <nameref name=\"seL4_NBRecv\"/> in <autoref label=\"sec:sys_nbrecv\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] src The capability to be invoked."]
    #[doc = " @param[out] sender The address to write sender information to."]
    #[doc = "               The sender information is the badge of the"]
    #[doc = "               endpoint capability that was invoked by the"]
    #[doc = "               sender, or the notification word of the"]
    #[doc = "               notification object that was signalled."]
    #[doc = "               This parameter is ignored if `NULL`."]
    #[doc = ""]
    #[doc = " @return A `seL4_MessageInfo_t` structure"]
    #[doc = " @xmlonly"]
    #[doc = " <docref>as described in <autoref label=\"sec:messageinfo\"/></docref>"]
    #[doc = " @endxmlonly"]
    pub fn seL4_Poll(src: seL4_CPtr, sender: *mut seL4_Word) -> seL4_MessageInfo_t;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Put Char\" label=\"sel4_debugputchar\"/> @endxmlonly"]
    #[doc = " @brief Output a single char through the kernel."]
    #[doc = ""]
    #[doc = " Use the kernel serial driver to output a single character. This is useful for"]
    #[doc = " debugging when a user level serial driver is not available."]
    #[doc = ""]
    #[doc = " @param c The character to output."]
    #[doc = ""]
    pub fn seL4_DebugPutChar(c: ctypes::c_char);
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Dump scheduler\" label=\"sel4_dumpscheduler\"/> @endxmlonly"]
    #[doc = " @brief Output the contents of the kernel scheduler."]
    #[doc = ""]
    #[doc = " Dump the state of the all TCB objects to kernel serial output. This system call"]
    #[doc = " will output a table containing:"]
    #[doc = "    - Address: the address of the TCB object for that thread,"]
    #[doc = "    - Name:    the name of the thread (if set),"]
    #[doc = "    - IP:      the contents of the instruction pointer the thread is at,"]
    #[doc = "    - Priority: the priority of that thread,"]
    #[doc = "    - State   : the state of the thread."]
    pub fn seL4_DebugDumpScheduler();
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Halt\" label=\"sel4_debughalt\"/> @endxmlonly"]
    #[doc = " @brief Halt the system."]
    #[doc = ""]
    #[doc = " This debugging system call will cause the kernel immediately cease responding to"]
    #[doc = " system calls. The kernel will switch permanently to the idle thread with"]
    #[doc = " interrupts disabled. Depending on the platform, the kernel may switch"]
    #[doc = " the hardware into a low-power state."]
    #[doc = ""]
    pub fn seL4_DebugHalt();
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Snapshot\" label=\"sel4_debugsnapshot\"/> @endxmlonly"]
    #[doc = " @brief Output a capDL dump of the current kernel state."]
    #[doc = ""]
    #[doc = " This debugging system call will output all of the capabilities in the current"]
    #[doc = " kernel using capDL."]
    #[doc = ""]
    pub fn seL4_DebugSnapshot();
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Cap Identify\" label=\"sel4_debugcapidentify\"/> @endxmlonly"]
    #[doc = " @brief Identify the type of a capability in the current cspace."]
    #[doc = ""]
    #[doc = " This debugging system call returns the type of capability in a capability"]
    #[doc = " slot in the current cspace. The type returned is not a libsel4 type, but"]
    #[doc = " refers to an internal seL4 type. This can be looked up in a built kernel by"]
    #[doc = " looking for the (generated) `enum cap_tag`, type `cap_tag_t`."]
    #[doc = ""]
    #[doc = " @param cap A capability slot in the current cspace."]
    #[doc = " @return The type of capability passed in."]
    #[doc = ""]
    pub fn seL4_DebugCapIdentify(cap: seL4_CPtr) -> seL4_Uint32;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Name Thread\" label=\"sel4_debugnamethread\"/> @endxmlonly"]
    #[doc = " @brief Name a thread."]
    #[doc = ""]
    #[doc = " Name a thread. This name will then be output by the kernel in all debugging output."]
    #[doc = " Note that the max name length that can be passed to this function is limited by the"]
    #[doc = " number of chars that will fit in an IPC message (`seL4_MsgMaxLength` multiplied by the"]
    #[doc = " amount of chars that fit in a word). However the name is also truncated in order to fit into a TCB object."]
    #[doc = " For some platforms you may need to increase `seL4_TCBBits` by 1 in a debug build in order to"]
    #[doc = " fit a long enough name."]
    #[doc = ""]
    #[doc = " @param tcb A capability to the tcb object for the thread to name."]
    #[doc = " @param name The name for the thread."]
    #[doc = ""]
    pub fn seL4_DebugNameThread(tcb: seL4_CPtr, name: *const ctypes::c_char);
}
extern "C" {
    pub static mut __sel4_ipc_buffer: *mut seL4_IPCBuffer;
}
extern "C" {
    pub fn seL4_SetIPCBuffer(ipc_buffer: *mut seL4_IPCBuffer);
}
extern "C" {
    pub fn seL4_GetIPCBuffer() -> *mut seL4_IPCBuffer;
}
extern "C" {
    pub fn seL4_GetMR(i: ctypes::c_int) -> seL4_Word;
}
extern "C" {
    pub fn seL4_SetMR(i: ctypes::c_int, mr: seL4_Word);
}
extern "C" {
    pub fn seL4_GetUserData() -> seL4_Word;
}
extern "C" {
    pub fn seL4_SetUserData(data: seL4_Word);
}
extern "C" {
    pub fn seL4_GetBadge(i: ctypes::c_int) -> seL4_Word;
}
extern "C" {
    pub fn seL4_GetCap(i: ctypes::c_int) -> seL4_CPtr;
}
extern "C" {
    pub fn seL4_SetCap(i: ctypes::c_int, cptr: seL4_CPtr);
}
extern "C" {
    pub fn seL4_GetCapReceivePath(
        receiveCNode: *mut seL4_CPtr,
        receiveIndex: *mut seL4_CPtr,
        receiveDepth: *mut seL4_Word,
    );
}
extern "C" {
    pub fn seL4_SetCapReceivePath(
        receiveCNode: seL4_CPtr,
        receiveIndex: seL4_CPtr,
        receiveDepth: seL4_Word,
    );
}
extern "C" {
    pub fn seL4_SendWithMRs(
        dest: seL4_CPtr,
        msgInfo: seL4_MessageInfo_t,
        mr0: *mut seL4_Word,
        mr1: *mut seL4_Word,
        mr2: *mut seL4_Word,
        mr3: *mut seL4_Word,
    );
}
extern "C" {
    pub fn seL4_NBSendWithMRs(
        dest: seL4_CPtr,
        msgInfo: seL4_MessageInfo_t,
        mr0: *mut seL4_Word,
        mr1: *mut seL4_Word,
        mr2: *mut seL4_Word,
        mr3: *mut seL4_Word,
    );
}
extern "C" {
    pub fn seL4_ReplyWithMRs(
        msgInfo: seL4_MessageInfo_t,
        mr0: *mut seL4_Word,
        mr1: *mut seL4_Word,
        mr2: *mut seL4_Word,
        mr3: *mut seL4_Word,
    );
}
extern "C" {
    pub fn seL4_RecvWithMRs(
        src: seL4_CPtr,
        sender: *mut seL4_Word,
        mr0: *mut seL4_Word,
        mr1: *mut seL4_Word,
        mr2: *mut seL4_Word,
        mr3: *mut seL4_Word,
    ) -> seL4_MessageInfo_t;
}
extern "C" {
    pub fn seL4_CallWithMRs(
        dest: seL4_CPtr,
        msgInfo: seL4_MessageInfo_t,
        mr0: *mut seL4_Word,
        mr1: *mut seL4_Word,
        mr2: *mut seL4_Word,
        mr3: *mut seL4_Word,
    ) -> seL4_MessageInfo_t;
}
extern "C" {
    pub fn seL4_ReplyRecvWithMRs(
        src: seL4_CPtr,
        msgInfo: seL4_MessageInfo_t,
        sender: *mut seL4_Word,
        mr0: *mut seL4_Word,
        mr1: *mut seL4_Word,
        mr2: *mut seL4_Word,
        mr3: *mut seL4_Word,
    ) -> seL4_MessageInfo_t;
}
extern "C" {
    pub fn seL4_DebugPutString(str: *mut ctypes::c_char);
}
extern "C" {
    pub fn strcpy(arg1: *mut ctypes::c_char, arg2: *const ctypes::c_char) -> *mut ctypes::c_char;
}
pub const invocation_label_InvalidInvocation: invocation_label = 0;
pub const invocation_label_UntypedRetype: invocation_label = 1;
pub const invocation_label_TCBReadRegisters: invocation_label = 2;
pub const invocation_label_TCBWriteRegisters: invocation_label = 3;
pub const invocation_label_TCBCopyRegisters: invocation_label = 4;
pub const invocation_label_TCBConfigure: invocation_label = 5;
pub const invocation_label_TCBSetPriority: invocation_label = 6;
pub const invocation_label_TCBSetMCPriority: invocation_label = 7;
pub const invocation_label_TCBSetSchedParams: invocation_label = 8;
pub const invocation_label_TCBSetIPCBuffer: invocation_label = 9;
pub const invocation_label_TCBSetSpace: invocation_label = 10;
pub const invocation_label_TCBSuspend: invocation_label = 11;
pub const invocation_label_TCBResume: invocation_label = 12;
pub const invocation_label_TCBBindNotification: invocation_label = 13;
pub const invocation_label_TCBUnbindNotification: invocation_label = 14;
pub const invocation_label_TCBSetTLSBase: invocation_label = 15;
pub const invocation_label_CNodeRevoke: invocation_label = 16;
pub const invocation_label_CNodeDelete: invocation_label = 17;
pub const invocation_label_CNodeCancelBadgedSends: invocation_label = 18;
pub const invocation_label_CNodeCopy: invocation_label = 19;
pub const invocation_label_CNodeMint: invocation_label = 20;
pub const invocation_label_CNodeMove: invocation_label = 21;
pub const invocation_label_CNodeMutate: invocation_label = 22;
pub const invocation_label_CNodeRotate: invocation_label = 23;
pub const invocation_label_CNodeSaveCaller: invocation_label = 24;
pub const invocation_label_IRQIssueIRQHandler: invocation_label = 25;
pub const invocation_label_IRQAckIRQ: invocation_label = 26;
pub const invocation_label_IRQSetIRQHandler: invocation_label = 27;
pub const invocation_label_IRQClearIRQHandler: invocation_label = 28;
pub const invocation_label_DomainSetSet: invocation_label = 29;
pub const invocation_label_nInvocationLabels: invocation_label = 30;
pub type invocation_label = u32;
pub const sel4_arch_invocation_label_ARMVSpaceClean_Data: sel4_arch_invocation_label = 30;
pub const sel4_arch_invocation_label_ARMVSpaceInvalidate_Data: sel4_arch_invocation_label = 31;
pub const sel4_arch_invocation_label_ARMVSpaceCleanInvalidate_Data: sel4_arch_invocation_label = 32;
pub const sel4_arch_invocation_label_ARMVSpaceUnify_Instruction: sel4_arch_invocation_label = 33;
pub const sel4_arch_invocation_label_ARMPageDirectoryMap: sel4_arch_invocation_label = 34;
pub const sel4_arch_invocation_label_ARMPageDirectoryUnmap: sel4_arch_invocation_label = 35;
pub const sel4_arch_invocation_label_nSeL4ArchInvocationLabels: sel4_arch_invocation_label = 36;
pub type sel4_arch_invocation_label = u32;
pub const arch_invocation_label_ARMPageTableMap: arch_invocation_label = 36;
pub const arch_invocation_label_ARMPageTableUnmap: arch_invocation_label = 37;
pub const arch_invocation_label_ARMPageMap: arch_invocation_label = 38;
pub const arch_invocation_label_ARMPageUnmap: arch_invocation_label = 39;
pub const arch_invocation_label_ARMPageClean_Data: arch_invocation_label = 40;
pub const arch_invocation_label_ARMPageInvalidate_Data: arch_invocation_label = 41;
pub const arch_invocation_label_ARMPageCleanInvalidate_Data: arch_invocation_label = 42;
pub const arch_invocation_label_ARMPageUnify_Instruction: arch_invocation_label = 43;
pub const arch_invocation_label_ARMPageGetAddress: arch_invocation_label = 44;
pub const arch_invocation_label_ARMASIDControlMakePool: arch_invocation_label = 45;
pub const arch_invocation_label_ARMASIDPoolAssign: arch_invocation_label = 46;
pub const arch_invocation_label_ARMVCPUSetTCB: arch_invocation_label = 47;
pub const arch_invocation_label_ARMVCPUInjectIRQ: arch_invocation_label = 48;
pub const arch_invocation_label_ARMVCPUReadReg: arch_invocation_label = 49;
pub const arch_invocation_label_ARMVCPUWriteReg: arch_invocation_label = 50;
pub const arch_invocation_label_ARMVCPUAckVPPI: arch_invocation_label = 51;
pub const arch_invocation_label_ARMIRQIssueIRQHandlerTrigger: arch_invocation_label = 52;
pub const arch_invocation_label_nArchInvocationLabels: arch_invocation_label = 53;
pub type arch_invocation_label = u32;
pub type __type_int_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_long_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_Uint8_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_Uint16_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_Uint32_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_Uint64_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_Time_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_Word_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_Bool_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_CapRights_t_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_CPtr_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_CNode_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_IRQHandler_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_IRQControl_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_TCB_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_Untyped_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_DomainSet_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_SchedContext_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_SchedControl_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_ARM_VMAttributes_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_ARM_Page_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_ARM_PageTable_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_ARM_PageDirectory_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_ARM_PageUpperDirectory_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_ARM_PageGlobalDirectory_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_ARM_VSpace_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_ARM_ASIDControl_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_ARM_ASIDPool_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_ARM_VCPU_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_ARM_IOSpace_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_ARM_IOPageTable_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_UserContext_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_ARM_SIDControl_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_ARM_SID_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_ARM_CBControl_size_incorrect = [ctypes::c_ulong; 1usize];
pub type __type_seL4_ARM_CB_size_incorrect = [ctypes::c_ulong; 1usize];
#[repr(C)]
pub struct seL4_ARM_Page_GetAddress {
    pub error: ctypes::c_int,
    pub paddr: seL4_Word,
}
#[test]
fn bindgen_test_layout_seL4_ARM_Page_GetAddress() {
    assert_eq!(
        ::core::mem::size_of::<seL4_ARM_Page_GetAddress>(),
        16usize,
        concat!("Size of: ", stringify!(seL4_ARM_Page_GetAddress))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_ARM_Page_GetAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_ARM_Page_GetAddress))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_ARM_Page_GetAddress>())).error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_ARM_Page_GetAddress),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_ARM_Page_GetAddress>())).paddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_ARM_Page_GetAddress),
            "::",
            stringify!(paddr)
        )
    );
}
pub type seL4_ARM_Page_GetAddress_t = seL4_ARM_Page_GetAddress;
#[repr(C)]
pub struct seL4_ARM_VCPU_ReadRegs {
    pub error: ctypes::c_int,
    pub value: seL4_Word,
}
#[test]
fn bindgen_test_layout_seL4_ARM_VCPU_ReadRegs() {
    assert_eq!(
        ::core::mem::size_of::<seL4_ARM_VCPU_ReadRegs>(),
        16usize,
        concat!("Size of: ", stringify!(seL4_ARM_VCPU_ReadRegs))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_ARM_VCPU_ReadRegs>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_ARM_VCPU_ReadRegs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_ARM_VCPU_ReadRegs>())).error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_ARM_VCPU_ReadRegs),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_ARM_VCPU_ReadRegs>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_ARM_VCPU_ReadRegs),
            "::",
            stringify!(value)
        )
    );
}
pub type seL4_ARM_VCPU_ReadRegs_t = seL4_ARM_VCPU_ReadRegs;
#[repr(C)]
pub struct seL4_ARM_SIDControl_GetFault {
    pub error: ctypes::c_int,
    pub status: seL4_Word,
    pub syndrome_0: seL4_Word,
    pub syndrome_1: seL4_Word,
}
#[test]
fn bindgen_test_layout_seL4_ARM_SIDControl_GetFault() {
    assert_eq!(
        ::core::mem::size_of::<seL4_ARM_SIDControl_GetFault>(),
        32usize,
        concat!("Size of: ", stringify!(seL4_ARM_SIDControl_GetFault))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_ARM_SIDControl_GetFault>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_ARM_SIDControl_GetFault))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<seL4_ARM_SIDControl_GetFault>())).error as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_ARM_SIDControl_GetFault),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<seL4_ARM_SIDControl_GetFault>())).status as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_ARM_SIDControl_GetFault),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<seL4_ARM_SIDControl_GetFault>())).syndrome_0 as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_ARM_SIDControl_GetFault),
            "::",
            stringify!(syndrome_0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<seL4_ARM_SIDControl_GetFault>())).syndrome_1 as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_ARM_SIDControl_GetFault),
            "::",
            stringify!(syndrome_1)
        )
    );
}
pub type seL4_ARM_SIDControl_GetFault_t = seL4_ARM_SIDControl_GetFault;
#[repr(C)]
pub struct seL4_ARM_CB_CBGetFault {
    pub error: ctypes::c_int,
    pub status: seL4_Word,
    pub address: seL4_Word,
}
#[test]
fn bindgen_test_layout_seL4_ARM_CB_CBGetFault() {
    assert_eq!(
        ::core::mem::size_of::<seL4_ARM_CB_CBGetFault>(),
        24usize,
        concat!("Size of: ", stringify!(seL4_ARM_CB_CBGetFault))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_ARM_CB_CBGetFault>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_ARM_CB_CBGetFault))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_ARM_CB_CBGetFault>())).error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_ARM_CB_CBGetFault),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_ARM_CB_CBGetFault>())).status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_ARM_CB_CBGetFault),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_ARM_CB_CBGetFault>())).address as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_ARM_CB_CBGetFault),
            "::",
            stringify!(address)
        )
    );
}
pub type seL4_ARM_CB_CBGetFault_t = seL4_ARM_CB_CBGetFault;
#[repr(C)]
pub struct seL4_TCB_GetBreakpoint {
    pub error: ctypes::c_int,
    pub vaddr: seL4_Word,
    pub type_: seL4_Word,
    pub size: seL4_Word,
    pub rw: seL4_Word,
    pub is_enabled: seL4_Bool,
}
#[test]
fn bindgen_test_layout_seL4_TCB_GetBreakpoint() {
    assert_eq!(
        ::core::mem::size_of::<seL4_TCB_GetBreakpoint>(),
        48usize,
        concat!("Size of: ", stringify!(seL4_TCB_GetBreakpoint))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_TCB_GetBreakpoint>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_TCB_GetBreakpoint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_TCB_GetBreakpoint>())).error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_TCB_GetBreakpoint),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_TCB_GetBreakpoint>())).vaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_TCB_GetBreakpoint),
            "::",
            stringify!(vaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_TCB_GetBreakpoint>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_TCB_GetBreakpoint),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_TCB_GetBreakpoint>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_TCB_GetBreakpoint),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_TCB_GetBreakpoint>())).rw as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_TCB_GetBreakpoint),
            "::",
            stringify!(rw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<seL4_TCB_GetBreakpoint>())).is_enabled as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_TCB_GetBreakpoint),
            "::",
            stringify!(is_enabled)
        )
    );
}
pub type seL4_TCB_GetBreakpoint_t = seL4_TCB_GetBreakpoint;
#[repr(C)]
pub struct seL4_TCB_ConfigureSingleStepping {
    pub error: ctypes::c_int,
    pub bp_was_consumed: seL4_Bool,
}
#[test]
fn bindgen_test_layout_seL4_TCB_ConfigureSingleStepping() {
    assert_eq!(
        ::core::mem::size_of::<seL4_TCB_ConfigureSingleStepping>(),
        8usize,
        concat!("Size of: ", stringify!(seL4_TCB_ConfigureSingleStepping))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_TCB_ConfigureSingleStepping>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(seL4_TCB_ConfigureSingleStepping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<seL4_TCB_ConfigureSingleStepping>())).error as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_TCB_ConfigureSingleStepping),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<seL4_TCB_ConfigureSingleStepping>())).bp_was_consumed
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_TCB_ConfigureSingleStepping),
            "::",
            stringify!(bp_was_consumed)
        )
    );
}
pub type seL4_TCB_ConfigureSingleStepping_t = seL4_TCB_ConfigureSingleStepping;
#[repr(C)]
pub struct seL4_SchedContext_Consumed {
    pub error: ctypes::c_int,
    pub consumed: seL4_Time,
}
#[test]
fn bindgen_test_layout_seL4_SchedContext_Consumed() {
    assert_eq!(
        ::core::mem::size_of::<seL4_SchedContext_Consumed>(),
        16usize,
        concat!("Size of: ", stringify!(seL4_SchedContext_Consumed))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_SchedContext_Consumed>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_SchedContext_Consumed))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<seL4_SchedContext_Consumed>())).error as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_SchedContext_Consumed),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<seL4_SchedContext_Consumed>())).consumed as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_SchedContext_Consumed),
            "::",
            stringify!(consumed)
        )
    );
}
pub type seL4_SchedContext_Consumed_t = seL4_SchedContext_Consumed;
#[repr(C)]
pub struct seL4_SchedContext_YieldTo {
    pub error: ctypes::c_int,
    pub consumed: seL4_Time,
}
#[test]
fn bindgen_test_layout_seL4_SchedContext_YieldTo() {
    assert_eq!(
        ::core::mem::size_of::<seL4_SchedContext_YieldTo>(),
        16usize,
        concat!("Size of: ", stringify!(seL4_SchedContext_YieldTo))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_SchedContext_YieldTo>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_SchedContext_YieldTo))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<seL4_SchedContext_YieldTo>())).error as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_SchedContext_YieldTo),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<seL4_SchedContext_YieldTo>())).consumed as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_SchedContext_YieldTo),
            "::",
            stringify!(consumed)
        )
    );
}
pub type seL4_SchedContext_YieldTo_t = seL4_SchedContext_YieldTo;
extern "C" {
    #[doc = " @xmlonly <manual name=\"Clean Data\" label=\"aarch64_vspace_clean\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Clean cached pages within a top level translation table @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"ch:vspace\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the top level translation table being operated on."]
    #[doc = " @param[in] start Start address"]
    #[doc = " @param[in] end End address"]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"end\"/> @endxmlonly  is in the kernel virtual address range."]
    #[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"start\"/> @endxmlonly  is greater than or equal to  @xmlonly <texttt text=\"end\"/> @endxmlonly ."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " @retval seL4_RangeError The specified range crosses a page boundary."]
    pub fn seL4_ARM_VSpace_Clean_Data(
        _service: seL4_ARM_VSpace,
        start: seL4_Word,
        end: seL4_Word,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Invalidate Data\" label=\"aarch64_vspace_invalidate\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Invalidate cached pages within a top level translation table @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"ch:vspace\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the top level translation table being operated on."]
    #[doc = " @param[in] start Start address"]
    #[doc = " @param[in] end End address"]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"end\"/> @endxmlonly  is in the kernel virtual address range."]
    #[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"start\"/> @endxmlonly  is greater than or equal to  @xmlonly <texttt text=\"end\"/> @endxmlonly ."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " @retval seL4_RangeError The specified range crosses a page boundary."]
    pub fn seL4_ARM_VSpace_Invalidate_Data(
        _service: seL4_ARM_VSpace,
        start: seL4_Word,
        end: seL4_Word,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Clean and Invalidate Data\" label=\"aarch64_vspace_clean_invalidate\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Clean and invalidate cached pages within a top level translation table @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"ch:vspace\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the top level translation table being operated on."]
    #[doc = " @param[in] start Start address"]
    #[doc = " @param[in] end End address"]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"end\"/> @endxmlonly  is in the kernel virtual address range."]
    #[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"start\"/> @endxmlonly  is greater than or equal to  @xmlonly <texttt text=\"end\"/> @endxmlonly ."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " @retval seL4_RangeError The specified range crosses a page boundary."]
    pub fn seL4_ARM_VSpace_CleanInvalidate_Data(
        _service: seL4_ARM_VSpace,
        start: seL4_Word,
        end: seL4_Word,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Unify Instruction\" label=\"aarch64_vspace_unify_instruction\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Clean and invalidate cached instruction pages to point of unification @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"ch:vspace\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the top level translation table being operated on."]
    #[doc = " @param[in] start Start address"]
    #[doc = " @param[in] end End address"]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"end\"/> @endxmlonly  is in the kernel virtual address range."]
    #[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"start\"/> @endxmlonly  is greater than or equal to  @xmlonly <texttt text=\"end\"/> @endxmlonly ."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " @retval seL4_RangeError The specified range crosses a page boundary."]
    pub fn seL4_ARM_VSpace_Unify_Instruction(
        _service: seL4_ARM_VSpace,
        start: seL4_Word,
        end: seL4_Word,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Map\" label=\"aarch64_page_directory_map\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Map a page directory @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " Map a page directory (level 2) to an upper page directory (level 1)."]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the page directory being operated on."]
    #[doc = " @param[in] vspace Top level translation table. Must be assigned to an ASID pool."]
    #[doc = " @param[in] vaddr Virtual adress"]
    #[doc = " @param[in] attr VM Attributes for the mapping. @xmlonly <docref>Possible values for this type are given in <autoref label=\"ch:vspace\"/>  .</docref> @endxmlonly"]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_DeleteFirst A mapping already exists for this level in  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  at  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly ."]
    #[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  does not have a Page Upper Directory mapped at  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly  is in the kernel virtual address range."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is already mapped in a VSpace."]
    pub fn seL4_ARM_PageDirectory_Map(
        _service: seL4_ARM_PageDirectory,
        vspace: seL4_CPtr,
        vaddr: seL4_Word,
        attr: seL4_ARM_VMAttributes,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Unmap\" label=\"aarch64_page_directory_unmap\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Unmap a page directory @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " Unmap a page directory (level 2) from an upper page directory (level 1)"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the page directory being operated on."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RevokeFirst A copy of the  @xmlonly <texttt text=\"_service\"/> @endxmlonly  capability exists."]
    pub fn seL4_ARM_PageDirectory_Unmap(_service: seL4_ARM_PageDirectory) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Map\" label=\"arm_pagetable_map\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Map a page table into an address space. @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " Takes a VSpace capability as an argument,"]
    #[doc = " and installs a reference to the invoked"]
    #[doc = " <texttt text=\"PageTable\"/> in the VSpace according to the provided virtual address."]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the page table being operated on."]
    #[doc = " @param[in] vspace Capability to the VSpace which will contain the mapping.                 Must be assigned to an ASID pool."]
    #[doc = " @param[in] vaddr Virtual address to map the page into."]
    #[doc = " @param[in] attr VM Attributes for the mapping.  @xmlonly <docref>Possible values for this type are given in <autoref label=\"ch:vspace\"/>  .</docref> @endxmlonly"]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_DeleteFirst A mapping already exists for this level in  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  at  @xmlonly <texttt text=\"vaddr.\"/> @endxmlonly"]
    #[doc = " @retval seL4_FailedLookup On aarch64,  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  does not have a Page Directory mapped at  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly  is in the kernel virtual address range."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is already mapped in a VSpace."]
    pub fn seL4_ARM_PageTable_Map(
        _service: seL4_ARM_PageTable,
        vspace: seL4_CPtr,
        vaddr: seL4_Word,
        attr: seL4_ARM_VMAttributes,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Unmap\" label=\"arm_pagetable_unmap\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Unmap a page table from its <texttt text=\"Page Directory\"/> and zero it out. @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " Removes the reference to the invoked <texttt text=\"Page Table\"/> from its"]
    #[doc = " containing <texttt text=\"Page Directory\"/>."]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the page table being operated on."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RevokeFirst A copy of the  @xmlonly <texttt text=\"_service\"/> @endxmlonly  capability exists."]
    pub fn seL4_ARM_PageTable_Unmap(_service: seL4_ARM_PageTable) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Map\" label=\"arm_page_map\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Map a page into an address space or update the mapping attributes. @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " Takes a VSpace capability, as an argument and installs a reference"]
    #[doc = " to the given <texttt text=\"Page\"/> in the lowest-level unmapped paging structure"]
    #[doc = " corresponding to the given address, or updates the mapping attributes if the page is"]
    #[doc = " already mapped at this address. The page must not already be mapped through this"]
    #[doc = " capability in a different VSpace or at a different address; the page may be mapped"]
    #[doc = " in multiple VSpaces by copying the capability."]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the page being operated on."]
    #[doc = " @param[in] vspace Capability to the VSpace which will contain the mapping.                 Must be assigned to an ASID pool."]
    #[doc = " @param[in] vaddr Virtual address to map the page into."]
    #[doc = " @param[in] rights Rights for the mapping. @xmlonly <docref>Possible values for this type are given in <autoref label=\"sec:cap_rights\"/>  .</docref> @endxmlonly"]
    #[doc = " @param[in] attr VM Attributes for the mapping. @xmlonly <docref>Possible values for this type are given in <autoref label=\"ch:vspace\"/>  .</docref> @endxmlonly"]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_AlignmentError The  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly  is not aligned to the page size of  @xmlonly <texttt text=\"_service\"/> @endxmlonly ."]
    #[doc = " @retval seL4_DeleteFirst A mapping already exists in  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  at  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly ."]
    #[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  does not have a paging structure at the required level mapped at  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is already mapped in  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  at a different virtual address."]
    #[doc = " Or,  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly  is in the kernel virtual address range."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is already mapped in a different VSpace."]
    pub fn seL4_ARM_Page_Map(
        _service: seL4_ARM_Page,
        vspace: seL4_CPtr,
        vaddr: seL4_Word,
        rights: seL4_CapRights_t,
        attr: seL4_ARM_VMAttributes,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Unmap\" label=\"arm_page_unmap\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Unmap a page. @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " Removes an existing mapping."]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the page being operated on."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_ARM_Page_Unmap(_service: seL4_ARM_Page) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Clean Data\" label=\"arm_page_clean_data\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Cleans the data cache out to RAM. The start and end are relative to the page being serviced. @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"ch:vspace\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the page being operated on."]
    #[doc = " @param[in] start_offset The offset, relative to the start of the page inclusive."]
    #[doc = " @param[in] end_offset The offset, relative to the start of the page exclusive."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_FailedLookup The VSpace of  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not mapped in a VSpace."]
    #[doc = " Or, if hypervisor support is configured, the requested range overlaps the kernel physical address range."]
    #[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"start_offset\"/> @endxmlonly  is greater than or equal to  @xmlonly <texttt text=\"end_offset\"/> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"start_offset\"/> @endxmlonly  or  @xmlonly <texttt text=\"end_offset\"/> @endxmlonly  exceeds the page size of  @xmlonly <texttt text=\"_service\"/> @endxmlonly ."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_ARM_Page_Clean_Data(
        _service: seL4_ARM_Page,
        start_offset: seL4_Word,
        end_offset: seL4_Word,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Invalidate Data\" label=\"arm_page_invalidate_data\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Invalidates the cache range within the given page. The start and end are relative to the page being serviced"]
    #[doc = " and should be aligned to a cache line boundary where possible."]
    #[doc = " An additional clean is performed on the outer cache lines if the start and end are"]
    #[doc = " not aligned, to clean out the bytes between the requested and the cache line boundary. @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"ch:vspace\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the page being operated on."]
    #[doc = " @param[in] start_offset The offset, relative to the start of the page inclusive."]
    #[doc = " @param[in] end_offset The offset, relative to the start of the page exclusive."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_FailedLookup The VSpace of  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not mapped in a VSpace."]
    #[doc = " Or, if hypervisor support is configured, the requested range overlaps the kernel physical address range."]
    #[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"start_offset\"/> @endxmlonly  is greater than or equal to  @xmlonly <texttt text=\"end_offset\"/> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"start_offset\"/> @endxmlonly  or  @xmlonly <texttt text=\"end_offset\"/> @endxmlonly  exceeds the page size of  @xmlonly <texttt text=\"_service\"/> @endxmlonly ."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_ARM_Page_Invalidate_Data(
        _service: seL4_ARM_Page,
        start_offset: seL4_Word,
        end_offset: seL4_Word,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Clean and Invalidate Data\" label=\"arm_page_clean_and_invalidate_data\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Clean and invalidates the cache range within the given page. The range will be flushed out to RAM."]
    #[doc = " The start and end are relative to the page being serviced. @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"ch:vspace\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the page being operated on."]
    #[doc = " @param[in] start_offset The offset, relative to the start of the page inclusive."]
    #[doc = " @param[in] end_offset The offset, relative to the start of the page exclusive."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_FailedLookup The VSpace of  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not mapped in a VSpace."]
    #[doc = " Or, if hypervisor support is configured, the requested range overlaps the kernel physical address range."]
    #[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"start_offset\"/> @endxmlonly  is greater than or equal to  @xmlonly <texttt text=\"end_offset\"/> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"start_offset\"/> @endxmlonly  or  @xmlonly <texttt text=\"end_offset\"/> @endxmlonly  exceeds the page size of  @xmlonly <texttt text=\"_service\"/> @endxmlonly ."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_ARM_Page_CleanInvalidate_Data(
        _service: seL4_ARM_Page,
        start_offset: seL4_Word,
        end_offset: seL4_Word,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Unify Instruction\" label=\"arm_page_unify_instruction\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Unify Instruction Cache. Cleans data lines to point of unification, invalidate"]
    #[doc = " corresponding instruction lines to point of unification, then invalidates branch"]
    #[doc = " predictors. The start and end are relative to the page being"]
    #[doc = " serviced. @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"ch:vspace\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the page being operated on."]
    #[doc = " @param[in] start_offset The offset, relative to the start of the page inclusive."]
    #[doc = " @param[in] end_offset The offset, relative to the start of the page exclusive."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_FailedLookup The VSpace of  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not mapped in a VSpace."]
    #[doc = " Or, if hypervisor support is configured, the requested range overlaps the kernel physical address range."]
    #[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"start_offset\"/> @endxmlonly  is greater than or equal to  @xmlonly <texttt text=\"end_offset\"/> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"start_offset\"/> @endxmlonly  or  @xmlonly <texttt text=\"end_offset\"/> @endxmlonly  exceeds the page size of  @xmlonly <texttt text=\"_service\"/> @endxmlonly ."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_ARM_Page_Unify_Instruction(
        _service: seL4_ARM_Page,
        start_offset: seL4_Word,
        end_offset: seL4_Word,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Get Address\" label=\"arm_page_get_address\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Get the physical address of the underlying frame. @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"ch:vspace\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the page being operated on."]
    #[doc = " @return @xmlonly"]
    #[doc = "                 A <texttt text=\"seL4_ARM_Page_GetAddress_t\"/> struct that contains a"]
    #[doc = "                 <texttt text=\"seL4_Word paddr\"/>, which holds the physical address of the page,"]
    #[doc = "                 and <texttt text=\"int error\"/>.<docref> See <autoref label=\"sec:errors\"/> for a description"]
    #[doc = "                 of the message register and tag contents upon error.</docref>"]
    #[doc = "              @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_ARM_Page_GetAddress(_service: seL4_ARM_Page) -> seL4_ARM_Page_GetAddress_t;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Make Pool\" label=\"arm_asid_control_make_pool\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Create an ASID Pool. @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " Together with a capability to <texttt text=\"Untyped Memory\"/>, which is passed as an argument,"]
    #[doc = " create an <texttt text=\"ASID Pool\"/>. The untyped capability must represent a"]
    #[doc = " 4K memory object. This will create an ASID pool with enough space for 1024 VSpaces."]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service The master ASIDControl capability being operated on."]
    #[doc = " @param[in] untyped Capability to an untyped memory object that will become the pool. Must be 4K bytes."]
    #[doc = " @param[in] root CPTR to the CNode that forms the root of the destination CSpace. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] index CPTR to the destination slot. Resolved from the root of the destination CSpace."]
    #[doc = " @param[in] depth Number of bits of index to resolve to find the destination slot."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
    #[doc = " Or, there are no more ASID pools available."]
    #[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"index\"/> @endxmlonly  or  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"untyped\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"untyped\"/> @endxmlonly  is not the exact size of an ASID pool object."]
    #[doc = " Or,  @xmlonly <texttt text=\"untyped\"/> @endxmlonly  is a device untyped  @xmlonly <docref>(see <autoref label=\"sec:kernmemalloc\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_RevokeFirst The  @xmlonly <texttt text=\"untyped\"/> @endxmlonly  has been used to retype an object."]
    #[doc = " Or, a copy of the  @xmlonly <texttt text=\"untyped\"/> @endxmlonly  capability exists."]
    pub fn seL4_ARM_ASIDControl_MakePool(
        _service: seL4_ARM_ASIDControl,
        untyped: seL4_Untyped,
        root: seL4_CNode,
        index: seL4_Word,
        depth: seL4_Uint8,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Asid Pool Assign\" label=\"arm_asidpool_assign\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Assign an ASID Pool. @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " Assigns an ASID to the VSpace passed in as an argument."]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service The ASID pool which is being assigned to. Must not be full. Each ASID pool can contain 1024 entries."]
    #[doc = " @param[in] vspace The VSpace that is being assigned to an ASID pool. Must not already be assigned to an ASID pool."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_DeleteFirst There are no more ASIDs available in  @xmlonly <texttt text=\"_service\"/> @endxmlonly ."]
    #[doc = " @retval seL4_FailedLookup The ASID pool of  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is no longer assigned."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is already assigned to an ASID pool."]
    pub fn seL4_ARM_ASIDPool_Assign(_service: seL4_ARM_ASIDPool, vspace: seL4_CPtr) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Set TCB\" label=\"arm_vcpu_set_tcb\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Bind a TCB to a virtual CPU @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " There is a 1:1 relationship between a virtual CPU and a TCB. If either (or both) of them is"]
    #[doc = " associated with another one, they will be dissociated, and then associated to the"]
    #[doc = " ones called in this system calls."]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the VCPU being operated on."]
    #[doc = " @param[in] tcb Capability to TCB to bind to a virtual CPU"]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"tcb\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_ARM_VCPU_SetTCB(_service: seL4_ARM_VCPU, tcb: seL4_TCB) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Inject IRQ\" label=\"arm_vcpu_inject_irq\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Inject an IRQ to a virtual CPU @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " TODO"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the VCPU being operated on."]
    #[doc = " @param[in] virq Virtual IRQ ID"]
    #[doc = " @param[in] priority Priority of the IRQ to be injected"]
    #[doc = " @param[in] group IRQ group"]
    #[doc = " @param[in] index IRQ index"]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_DeleteFirst The  @xmlonly <texttt text=\"index\"/> @endxmlonly  is in use."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"virq\"/> @endxmlonly ,  @xmlonly <texttt text=\"priority\"/> @endxmlonly ,  @xmlonly <texttt text=\"group\"/> @endxmlonly , or  @xmlonly <texttt text=\"index\"/> @endxmlonly  is invalid."]
    pub fn seL4_ARM_VCPU_InjectIRQ(
        _service: seL4_ARM_VCPU,
        virq: seL4_Uint16,
        priority: seL4_Uint8,
        group: seL4_Uint8,
        index: seL4_Uint8,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Read Registers\" label=\"arm_vcpu_read_registers\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Read a virtual CPU register @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " TODO"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the VCPU being operated on."]
    #[doc = " @param[in] field Register to read from a VCPU"]
    #[doc = " @return @xmlonly @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"field\"/> @endxmlonly  is invalid."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_ARM_VCPU_ReadRegs(
        _service: seL4_ARM_VCPU,
        field: seL4_Word,
    ) -> seL4_ARM_VCPU_ReadRegs_t;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Write Registers\" label=\"arm_vcpu_write_registers\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Write a virtual CPU register @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " TODO"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the VCPU being operated on."]
    #[doc = " @param[in] field Register ID to write to a VCPU"]
    #[doc = " @param[in] value Value to be written to the VCPU register"]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"field\"/> @endxmlonly  is invalid."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_ARM_VCPU_WriteRegs(
        _service: seL4_ARM_VCPU,
        field: seL4_Word,
        value: seL4_Word,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Acknowledge Virtual PPI IRQ\" label=\"arm_vcpu_acknowledge_virtual_ppi_irq\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Acknowledge a PPI IRQ previously forwarded from a VPPIEvent fault @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " Acknowledge and unmask the PPI interrupt so that further interrupts can be forwarded"]
    #[doc = " through VPPIEvent faults."]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the VCPU being operated on."]
    #[doc = " @param[in] irq irq to ack."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"irq\"/> @endxmlonly  is invalid."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_ARM_VCPU_AckVPPI(_service: seL4_ARM_VCPU, irq: seL4_Word) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"GetTrigger\" label=\"arm_irq_controlgettrigger\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Create an IRQ handler capability and specify the trigger method (edge or level). @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:interrupts\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service An IRQControl capability. This gives you the authority to make this call."]
    #[doc = " @param[in] irq The IRQ that you want this capability to handle."]
    #[doc = " @param[in] trigger Indicates whether this IRQ is edge (1) or level (0) triggered."]
    #[doc = " @param[in] root CPTR to the CNode that forms the root of the destination CSpace. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] index CPTR to the destination slot. Resolved from the root of the destination CSpace."]
    #[doc = " @param[in] depth Number of bits of dest_index to resolve to find the destination slot."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
    #[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"index\"/> @endxmlonly  or  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or, the platform does not support setting the IRQ trigger."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"irq\"/> @endxmlonly  is invalid."]
    #[doc = " Or,  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_RevokeFirst An IRQ handler capability for  @xmlonly <texttt text=\"irq\"/> @endxmlonly  has already been created."]
    pub fn seL4_IRQControl_GetTrigger(
        _service: seL4_IRQControl,
        irq: seL4_Word,
        trigger: seL4_Word,
        root: seL4_CNode,
        index: seL4_Word,
        depth: seL4_Uint8,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Retype\" label=\"untyped_retype\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Retype an untyped object @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " Given a capability, <texttt text=\"_service\"/>, to an untyped object,"]
    #[doc = " creates <texttt text=\"num_objects\"/> of the requested type. Creates"]
    #[doc = " <texttt text=\"num_objects\"/> capabilities to the new objects starting"]
    #[doc = " at <texttt text=\"node_offset\"/> in the CNode specified by"]
    #[doc = " <texttt text=\"root\"/>, <texttt text=\"node_index\"/>, and"]
    #[doc = " <texttt text=\"node_depth\"/>."]
    #[doc = ""]
    #[doc = " For variable-sized"]
    #[doc = " kernel objects, the <texttt text=\"size_bits\"/> argument is used to"]
    #[doc = " determine the size of objects to create. The relationship between"]
    #[doc = " <texttt text=\"size_bits\"/> and object size depends on the type of object"]
    #[doc = " being created. <docref>See <autoref label=\"sec:object_sizes\"/> for more information"]
    #[doc = " about object sizes.</docref>"]
    #[doc = ""]
    #[doc = " <docref>See <autoref label=\"sec:kernmemalloc\"/> for more information about how untyped"]
    #[doc = " memory is retyped.</docref>"]
    #[doc = ""]
    #[doc = " <docref>See <autoref label=\"sec:caps_to_new_objects\"/> for more information about the"]
    #[doc = " placement of capabilities to created objects.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service CPTR to an untyped object."]
    #[doc = " @param[in] type The seL4 object type that we are retyping to."]
    #[doc = " @param[in] size_bits Used to determine the size of variable-sized objects."]
    #[doc = " @param[in] root CPTR to the CNode at the root of the destination CSpace."]
    #[doc = " @param[in] node_index CPTR to the destination CNode. Resolved relative to the root parameter."]
    #[doc = " @param[in] node_depth Number of bits of node_index to translate when addressing the destination CNode."]
    #[doc = " @param[in] node_offset Number of slots into the node at which capabilities start being placed."]
    #[doc = " @param[in] num_objects Number of capabilities to create."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_DeleteFirst A capability exists in the destination window of the CNode."]
    #[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"root\"/> @endxmlonly ,  @xmlonly <texttt text=\"node_index\"/> @endxmlonly , or  @xmlonly <texttt text=\"node_depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"size_bits\"/> @endxmlonly  is too big or too small for the requested object type."]
    #[doc = " Or,  @xmlonly <texttt text=\"type\"/> @endxmlonly  cannot be created from a device untyped  @xmlonly <docref>(see <autoref label=\"sec:kernmemalloc\"/>)</docref> @endxmlonly ."]
    #[doc = " Or, the requested object  @xmlonly <texttt text=\"type\"/> @endxmlonly  does not exist."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_NotEnoughMemory The total size of the new objects exceeds the space available."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"num_objects\"/> @endxmlonly  do not fit in the destination CNode at  @xmlonly <texttt text=\"node_offset\"/> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"num_objects\"/> @endxmlonly  is greater than  @xmlonly <texttt text=\"CONFIG_RETYPE_FAN_OUT_LIMIT\"/> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"size_bits\"/> @endxmlonly  is too large."]
    pub fn seL4_Untyped_Retype(
        _service: seL4_Untyped,
        type_: seL4_Word,
        size_bits: seL4_Word,
        root: seL4_CNode,
        node_index: seL4_Word,
        node_depth: seL4_Word,
        node_offset: seL4_Word,
        num_objects: seL4_Word,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Read Registers\" label=\"tcb_readregisters\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Read a thread's registers into the first <texttt text=\"count\"/> fields of a given"]
    #[doc = " seL4_UserContext @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:read_write_registers\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the TCB which is being operated on."]
    #[doc = " @param[in] suspend_source The invocation should also suspend the source thread."]
    #[doc = " @param[in] arch_flags Architecture dependent flags. These have no meaning on x86, ARM, and RISC-V."]
    #[doc = " @param[in] count The number of registers to read."]
    #[doc = " @param[out] regs The structure to read the registers into."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is the current thread's TCB."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"count\"/> @endxmlonly  requested too few or too many registers."]
    pub fn seL4_TCB_ReadRegisters(
        _service: seL4_TCB,
        suspend_source: seL4_Bool,
        arch_flags: seL4_Uint8,
        count: seL4_Word,
        regs: *mut seL4_UserContext,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Write Registers\" label=\"tcb_writeregisters\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Set a thread's registers to the first <texttt text=\"count\"/> fields of a given seL4_UserContext @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:read_write_registers\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the TCB which is being operated on."]
    #[doc = " @param[in] resume_target The invocation should also resume the destination thread."]
    #[doc = " @param[in] arch_flags Architecture dependent flags. These have no meaning on x86, ARM, and RISC-V."]
    #[doc = " @param[in] count The number of registers to be set."]
    #[doc = " @param[in] regs Data structure containing the new register values."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is the current thread's TCB."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_TCB_WriteRegisters(
        _service: seL4_TCB,
        resume_target: seL4_Bool,
        arch_flags: seL4_Uint8,
        count: seL4_Word,
        regs: *mut seL4_UserContext,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Copy Registers\" label=\"tcb_copyregisters\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Copy the registers from one thread to another @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " In the context of this function, frame registers are those that are read, modified or preserved by a"]
    #[doc = " system call and integer registers are those that are not. Refer to the seL4 userland library source for specifics."]
    #[doc = " <docref><autoref label=\"sec:thread_deactivation\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the TCB which is being operated on. This is the destination TCB."]
    #[doc = " @param[in] source Cap to the source TCB."]
    #[doc = " @param[in] suspend_source The invocation should also suspend the source thread."]
    #[doc = " @param[in] resume_target The invocation should also resume the destination thread."]
    #[doc = " @param[in] transfer_frame Frame registers should be transferred."]
    #[doc = " @param[in] transfer_integer Integer registers should be transferred."]
    #[doc = " @param[in] arch_flags Architecture dependent flags. These have no meaning on x86, ARM, and RISC-V."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"source\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_TCB_CopyRegisters(
        _service: seL4_TCB,
        source: seL4_TCB,
        suspend_source: seL4_Bool,
        resume_target: seL4_Bool,
        transfer_frame: seL4_Bool,
        transfer_integer: seL4_Bool,
        arch_flags: seL4_Uint8,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Configure\" label=\"tcb_configure\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Set the parameters of a TCB @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:threads\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the TCB which is being operated on."]
    #[doc = " @param[in] fault_ep CPTR to the endpoint which receives IPCs when this thread faults. This capability is in the CSpace of the thread being configured."]
    #[doc = " @param[in] cspace_root The new CSpace root."]
    #[doc = " @param[in] cspace_root_data Optionally set the guard and guard size of the new root CNode. If set to zero, this parameter has no effect."]
    #[doc = " @param[in] vspace_root The new VSpace root."]
    #[doc = " @param[in] vspace_root_data Has no effect on x86 or ARM processors."]
    #[doc = " @param[in] buffer Location of the thread's IPC buffer. Must be 512-byte aligned. The IPC buffer may not cross a page boundary."]
    #[doc = " @param[in] bufferFrame Capability to a page containing the thread's IPC buffer."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly ,  @xmlonly <texttt text=\"bufferFrame\"/> @endxmlonly ,  @xmlonly <texttt text=\"cspace_root\"/> @endxmlonly , or  @xmlonly <texttt text=\"vspace_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"vspace_root\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " Or,  @xmlonly <texttt text=\"cspace_root_data\"/> @endxmlonly  is invalid."]
    #[doc = " Or,  @xmlonly <texttt text=\"buffer\"/> @endxmlonly  is not aligned."]
    #[doc = " Or,  @xmlonly <texttt text=\"bufferFrame\"/> @endxmlonly  is retyped from a device untyped  @xmlonly <docref>(see <autoref label=\"sec:kernmemalloc\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RevokeFirst The  @xmlonly <texttt text=\"bufferFrame\"/> @endxmlonly ,  @xmlonly <texttt text=\"cspace_root\"/> @endxmlonly , or  @xmlonly <texttt text=\"vspace_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_TCB_Configure(
        _service: seL4_TCB,
        fault_ep: seL4_Word,
        cspace_root: seL4_CNode,
        cspace_root_data: seL4_Word,
        vspace_root: seL4_CPtr,
        vspace_root_data: seL4_Word,
        buffer: seL4_Word,
        bufferFrame: seL4_CPtr,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Set Priority\" label=\"tcb_setpriority\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Change a thread's priority @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:sched\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the TCB which is being operated on."]
    #[doc = " @param[in] authority Capability to the TCB to use the MCP from when setting the priority."]
    #[doc = " @param[in] priority The thread's new priority."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"authority\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"priority\"/> @endxmlonly  is greater than the maximum controlled priority of  @xmlonly <texttt text=\"authority\"/> @endxmlonly ."]
    pub fn seL4_TCB_SetPriority(
        _service: seL4_TCB,
        authority: seL4_TCB,
        priority: seL4_Word,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Set Maximum Controlled Priority\" label=\"tcb_setmcpriority\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Change a thread's maximum controlled priority @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:sched\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the TCB which is being operated on."]
    #[doc = " @param[in] authority Capability to the TCB to use the MCP from when setting the MCP."]
    #[doc = " @param[in] mcp The thread's new maximum controlled priority."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"authority\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"mcp\"/> @endxmlonly  is greater than the maximum controlled priority of  @xmlonly <texttt text=\"authority\"/> @endxmlonly ."]
    pub fn seL4_TCB_SetMCPriority(
        _service: seL4_TCB,
        authority: seL4_TCB,
        mcp: seL4_Word,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Set Sched Params\" label=\"tcb_setschedparams\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Change a thread's priority and maximum controlled priority. @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:sched\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the TCB which is being operated on."]
    #[doc = " @param[in] authority Capability to the TCB to use the MCP from when setting the priority and MCP."]
    #[doc = " @param[in] mcp The thread's new maximum controlled priority."]
    #[doc = " @param[in] priority The thread's new priority."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"authority\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"mcp\"/> @endxmlonly  is greater than the maximum controlled priority of  @xmlonly <texttt text=\"authority\"/> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"priority\"/> @endxmlonly  is greater than the maximum controlled priority of  @xmlonly <texttt text=\"authority\"/> @endxmlonly ."]
    pub fn seL4_TCB_SetSchedParams(
        _service: seL4_TCB,
        authority: seL4_TCB,
        mcp: seL4_Word,
        priority: seL4_Word,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Set IPC Buffer\" label=\"tcb_setipcbuffer\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Set a thread's IPC buffer @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " See Sections <shortref sec=\"threads\"/> and <shortref sec=\"messageinfo\"/>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the TCB which is being operated on."]
    #[doc = " @param[in] buffer Location of the thread's IPC buffer. Must be 512-byte aligned. The IPC buffer may not cross a page boundary."]
    #[doc = " @param[in] bufferFrame Capability to a page containing the thread's IPC buffer."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_AlignmentError The  @xmlonly <texttt text=\"buffer\"/> @endxmlonly  is not aligned."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"bufferFrame\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"bufferFrame\"/> @endxmlonly  is retyped from a device untyped  @xmlonly <docref>(see <autoref label=\"sec:kernmemalloc\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RevokeFirst The  @xmlonly <texttt text=\"bufferFrame\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_TCB_SetIPCBuffer(
        _service: seL4_TCB,
        buffer: seL4_Word,
        bufferFrame: seL4_CPtr,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Set Space\" label=\"tcb_setspace\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Set the fault endpoint, CSpace and VSpace of a thread @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:threads\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the TCB which is being operated on."]
    #[doc = " @param[in] fault_ep CPTR to the endpoint which receives IPCs when this thread faults. This capability is in the CSpace of the thread being configured."]
    #[doc = " @param[in] cspace_root The new CSpace root."]
    #[doc = " @param[in] cspace_root_data Optionally set the guard and guard size of the new root CNode. If set to zero, this parameter has no effect."]
    #[doc = " @param[in] vspace_root The new VSpace root."]
    #[doc = " @param[in] vspace_root_data Has no effect on x86 or ARM processors."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly ,  @xmlonly <texttt text=\"cspace_root\"/> @endxmlonly , or  @xmlonly <texttt text=\"vspace_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"vspace_root\"/> @endxmlonly  is not assigned to an ASID pool."]
    #[doc = " Or,  @xmlonly <texttt text=\"cspace_root_data\"/> @endxmlonly  is invalid."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RevokeFirst The  @xmlonly <texttt text=\"cspace_root\"/> @endxmlonly  or  @xmlonly <texttt text=\"vspace_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_TCB_SetSpace(
        _service: seL4_TCB,
        fault_ep: seL4_Word,
        cspace_root: seL4_CNode,
        cspace_root_data: seL4_Word,
        vspace_root: seL4_CPtr,
        vspace_root_data: seL4_Word,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Suspend\" label=\"tcb_suspend\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Suspend a thread @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:thread_deactivation\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the TCB which is being operated on."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_TCB_Suspend(_service: seL4_TCB) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Resume\" label=\"tcb_resume\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Resume a thread @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:thread_deactivation\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the TCB which is being operated on."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_TCB_Resume(_service: seL4_TCB) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Bind Notification\" label=\"tcb_bindnotification\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Binds a notification object to a <obj name=\"TCB\"/> @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:notification-binding\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the TCB which is being operated on."]
    #[doc = " @param[in] notification Notification to bind."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"notification\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"notification\"/> @endxmlonly  is already bound."]
    #[doc = " Or,  @xmlonly <texttt text=\"notification\"/> @endxmlonly  does not have Read rights to the Notification  @xmlonly <docref>(see <autoref label=\"sec:cap_rights\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_TCB_BindNotification(_service: seL4_TCB, notification: seL4_CPtr) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Unbind Notification\" label=\"tcb_unbindnotification\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Unbinds any notification object from a <obj name=\"TCB\"/> @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:notification-binding\"/></docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the TCB which is being operated on."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not bound to a notification."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_TCB_UnbindNotification(_service: seL4_TCB) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Set TLS Base\" label=\"tcb_settlsbase\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Set the TLS base of the target TCB. This intended for use on architectures where the register"]
    #[doc = " used for TLS can only be written to in privilidged mode @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = ""]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability to the TCB which is being operated on."]
    #[doc = " @param[in] tls_base The TLS base to set"]
    #[doc = " @return @xmlonly"]
    #[doc = "               @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_TCB_SetTLSBase(_service: seL4_TCB, tls_base: seL4_Word) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Revoke\" label=\"cnode_revoke\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Delete all child capabilities of a capability @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service CPTR to the CNode at the root of the CSpace where the capability will be found. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] index CPTR to the capability. Resolved from the root of the _service parameter."]
    #[doc = " @param[in] depth Number of bits of index to resolve to find the capability being operated on."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"index\"/> @endxmlonly  or  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    pub fn seL4_CNode_Revoke(
        _service: seL4_CNode,
        index: seL4_Word,
        depth: seL4_Uint8,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Delete\" label=\"cnode_delete\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Delete a capability @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service CPTR to the CNode at the root of the CSpace where the capability will be found. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] index CPTR to the capability. Resolved from the root of the _service parameter."]
    #[doc = " @param[in] depth Number of bits of index to resolve to find the capability being operated on."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"index\"/> @endxmlonly  or  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    pub fn seL4_CNode_Delete(
        _service: seL4_CNode,
        index: seL4_Word,
        depth: seL4_Uint8,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Cancel Badged Sends\" label=\"cnode_cancelbadgedsends\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly The cancel badged sends method is intend to allow for the reuse of badges by an"]
    #[doc = " authority. When used with a badged endpoint capability it"]
    #[doc = " will cancel any outstanding send operations for that endpoint and badge."]
    #[doc = " This operation has no effect on un-badged or other objects. @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service CPTR to the CNode at the root of the CSpace where the capability will be found. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] index CPTR to the capability. Resolved from the root of the _service parameter."]
    #[doc = " @param[in] depth Number of bits of index to resolve to find the capability being operated on."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"index\"/> @endxmlonly  or  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or, the capability does not have full rights to the Endpoint  @xmlonly <docref>(see <autoref label=\"sec:cap_rights\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    pub fn seL4_CNode_CancelBadgedSends(
        _service: seL4_CNode,
        index: seL4_Word,
        depth: seL4_Uint8,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Copy\" label=\"cnode_copy\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Copy a capability, setting its access rights whilst doing so @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service CPTR to the CNode that forms the root of the destination CSpace. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] dest_index CPTR to the destination slot. Resolved from the root of the destination CSpace."]
    #[doc = " @param[in] dest_depth Number of bits of dest_index to resolve to find the destination slot."]
    #[doc = " @param[in] src_root CPTR to the CNode that forms the root of the source CSpace. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] src_index CPTR to the source slot. Resolved from the root of the source CSpace."]
    #[doc = " @param[in] src_depth Number of bits of src_index to resolve to find the source slot."]
    #[doc = " @param[in] rights The rights inherited by the new capability. @xmlonly <docref>Possible values for this type are given in <autoref label=\"sec:cap_rights\"/>  .</docref> @endxmlonly"]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
    #[doc = " @retval seL4_FailedLookup The index or depth of the source or destination is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"src_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or, the source slot is empty."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or, the source capability cannot be derived  @xmlonly <docref>(see <autoref label=\"sec:cap_derivation\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"dest_depth\"/> @endxmlonly  or  @xmlonly <texttt text=\"src_depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_RevokeFirst The source capability cannot be derived  @xmlonly <docref>(see <autoref label=\"sec:cap_derivation\"/>)</docref> @endxmlonly ."]
    pub fn seL4_CNode_Copy(
        _service: seL4_CNode,
        dest_index: seL4_Word,
        dest_depth: seL4_Uint8,
        src_root: seL4_CNode,
        src_index: seL4_Word,
        src_depth: seL4_Uint8,
        rights: seL4_CapRights_t,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Mint\" label=\"cnode_mint\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Copy a capability, setting its access rights and badge whilst doing so @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service CPTR to the CNode that forms the root of the destination CSpace. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] dest_index CPTR to the destination slot. Resolved from the root of the destination CSpace."]
    #[doc = " @param[in] dest_depth Number of bits of dest_index to resolve to find the destination slot."]
    #[doc = " @param[in] src_root CPTR to the CNode that forms the root of the source CSpace. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] src_index CPTR to the source slot. Resolved from the root of the source CSpace."]
    #[doc = " @param[in] src_depth Number of bits of src_index to resolve to find the source slot."]
    #[doc = " @param[in] rights The rights inherited by the new capability. @xmlonly <docref>Possible values for this type are given in <autoref label=\"sec:cap_rights\"/>  .</docref> @endxmlonly"]
    #[doc = " @param[in] badge Badge or guard to be applied to the new capability. For badges on 32-bit platforms, the high 4 bits are ignored."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
    #[doc = " @retval seL4_FailedLookup The index or depth of the source or destination is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"src_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or, the source slot is empty."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or, the source capability cannot be derived  @xmlonly <docref>(see <autoref label=\"sec:cap_derivation\"/>)</docref> @endxmlonly ."]
    #[doc = " Or, the badge or guard value is invalid."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"dest_depth\"/> @endxmlonly  or  @xmlonly <texttt text=\"src_depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_RevokeFirst The source capability cannot be derived  @xmlonly <docref>(see <autoref label=\"sec:cap_derivation\"/>)</docref> @endxmlonly ."]
    pub fn seL4_CNode_Mint(
        _service: seL4_CNode,
        dest_index: seL4_Word,
        dest_depth: seL4_Uint8,
        src_root: seL4_CNode,
        src_index: seL4_Word,
        src_depth: seL4_Uint8,
        rights: seL4_CapRights_t,
        badge: seL4_Word,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Move\" label=\"cnode_move\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Move a capability @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service CPTR to the CNode that forms the root of the destination CSpace. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] dest_index CPTR to the destination slot. Resolved from the root of the destination CSpace."]
    #[doc = " @param[in] dest_depth Number of bits of dest_index to resolve to find the destination slot."]
    #[doc = " @param[in] src_root CPTR to the CNode that forms the root of the source CSpace. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] src_index CPTR to the source slot. Resolved from the root of the source CSpace."]
    #[doc = " @param[in] src_depth Number of bits of src_index to resolve to find the source slot."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
    #[doc = " @retval seL4_FailedLookup The index or depth of the source or destination is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"src_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or, the source slot is empty."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"dest_depth\"/> @endxmlonly  or  @xmlonly <texttt text=\"src_depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    pub fn seL4_CNode_Move(
        _service: seL4_CNode,
        dest_index: seL4_Word,
        dest_depth: seL4_Uint8,
        src_root: seL4_CNode,
        src_index: seL4_Word,
        src_depth: seL4_Uint8,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Mutate\" label=\"cnode_mutate\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Move a capability, setting its guard in the process. This"]
    #[doc = " operation is mostly useful for setting the guard of a CNode"]
    #[doc = " capability without losing revokability of that CNode capability."]
    #[doc = " All other uses can be replaced by a combination of Mint and"]
    #[doc = " Delete. @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service CPTR to the CNode that forms the root of the destination CSpace. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] dest_index CPTR to the destination slot. Resolved from the root of the destination CSpace."]
    #[doc = " @param[in] dest_depth Number of bits of dest_index to resolve to find the destination slot."]
    #[doc = " @param[in] src_root CPTR to the CNode that forms the root of the source CSpace. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] src_index CPTR to the source slot. Resolved from the root of the source CSpace."]
    #[doc = " @param[in] src_depth Number of bits of src_index to resolve to find the source slot."]
    #[doc = " @param[in] badge Guard to be applied to the new capability."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
    #[doc = " @retval seL4_FailedLookup The index or depth of the source or destination is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"src_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or, the source slot is empty."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or, the guard value is invalid."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"dest_depth\"/> @endxmlonly  or  @xmlonly <texttt text=\"src_depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    pub fn seL4_CNode_Mutate(
        _service: seL4_CNode,
        dest_index: seL4_Word,
        dest_depth: seL4_Uint8,
        src_root: seL4_CNode,
        src_index: seL4_Word,
        src_depth: seL4_Uint8,
        badge: seL4_Word,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Rotate\" label=\"cnode_rotate\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Given 3 capability slots - a destination, pivot and source - move the capability in the"]
    #[doc = " pivot slot to the destination slot and the capability in the source slot to the pivot slot @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service CPTR to the CNode at the root of the CSpace where the destination slot will be found. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] dest_index CPTR to the destination slot. Resolved relative to _service. Must be empty unless it refers to the same slot as the source slot."]
    #[doc = " @param[in] dest_depth Depth to resolve dest_index to."]
    #[doc = " @param[in] dest_badge The new capdata for the capability that ends up in the destination slot."]
    #[doc = " @param[in] pivot_root CPTR to the CNode at the root of the CSpace where the pivot slot will be found. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] pivot_index CPTR to the pivot slot. Resolved relative to pivot_root. The resolved slot must not refer to the source or destination slots."]
    #[doc = " @param[in] pivot_depth Depth to resolve pivot_index to."]
    #[doc = " @param[in] pivot_badge The new capdata for the capability that ends up in the pivot slot."]
    #[doc = " @param[in] src_root CPTR to the CNode at the root of the CSpace where the source slot will be found. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] src_index CPTR to the source slot. Resolved relative to src_root."]
    #[doc = " @param[in] src_depth Depth to resolve src_index to."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_DeleteFirst If the destination is not the same slot as the source and the destination slot contains a capability."]
    #[doc = " @retval seL4_FailedLookup The index or depth of the source, destination, or pivot is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"src_root\"/> @endxmlonly  or  @xmlonly <texttt text=\"pivot_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or, the source or pivot slot is empty."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or, the pivot is the same slot as the source or destination."]
    #[doc = " Or, the guard value on the destination or pivot is invalid."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"dest_depth\"/> @endxmlonly ,  @xmlonly <texttt text=\"src_depth\"/> @endxmlonly , or  @xmlonly <texttt text=\"pivot_depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    pub fn seL4_CNode_Rotate(
        _service: seL4_CNode,
        dest_index: seL4_Word,
        dest_depth: seL4_Uint8,
        dest_badge: seL4_Word,
        pivot_root: seL4_CNode,
        pivot_index: seL4_Word,
        pivot_depth: seL4_Uint8,
        pivot_badge: seL4_Word,
        src_root: seL4_CNode,
        src_index: seL4_Word,
        src_depth: seL4_Uint8,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Save Caller\" label=\"cnode_savecaller\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Save the reply capability from the last time the thread was called in the given CSpace so that it can be invoked later @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service CPTR to the CNode at the root of the CSpace where the capability is to be saved. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] index CPTR to the slot in which to save the capability. Resolved from the root of the _service parameter."]
    #[doc = " @param[in] depth Number of bits of index to resolve to find the slot being targeted."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
    #[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"index\"/> @endxmlonly  or  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    pub fn seL4_CNode_SaveCaller(
        _service: seL4_CNode,
        index: seL4_Word,
        depth: seL4_Uint8,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Get\" label=\"irq_controlget\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Create an IRQ handler capability @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:interrupts\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service An IRQControl capability. This gives you the authority to make this call."]
    #[doc = " @param[in] irq The IRQ that you want this capability to handle."]
    #[doc = " @param[in] root CPTR to the CNode that forms the root of the destination CSpace. Must be at a depth equivalent to the wordsize."]
    #[doc = " @param[in] index CPTR to the destination slot. Resolved from the root of the destination CSpace."]
    #[doc = " @param[in] depth Number of bits of dest_index to resolve to find the destination slot."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
    #[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"root\"/> @endxmlonly ,  @xmlonly <texttt text=\"index\"/> @endxmlonly , or  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or, on x86, an IOAPIC is being used."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"irq\"/> @endxmlonly  is invalid for the target architecture."]
    #[doc = " Or, on x86,  @xmlonly <texttt text=\"irq\"/> @endxmlonly  is not in the ISA IRQ range."]
    #[doc = " Or,  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
    #[doc = " @retval seL4_RevokeFirst An IRQ handler capability for  @xmlonly <texttt text=\"irq\"/> @endxmlonly  has already been created."]
    pub fn seL4_IRQControl_Get(
        _service: seL4_IRQControl,
        irq: seL4_Word,
        root: seL4_CNode,
        index: seL4_Word,
        depth: seL4_Uint8,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Acknowledge\" label=\"irq_handleracknowledge\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Acknowledge the receipt of an interrupt and re-enable it @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:interrupts\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service The IRQ handler capability."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_IRQHandler_Ack(_service: seL4_IRQHandler) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Set Notification\" label=\"irq_handlersetnotification\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Set the notification which the kernel will signal on interrupts"]
    #[doc = " controlled by the supplied IRQ handler capability @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:interrupts\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service The IRQ handler capability."]
    #[doc = " @param[in] notification The notification which the IRQs will signal."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"notification\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " Or,  @xmlonly <texttt text=\"notification\"/> @endxmlonly  does not have the Write right  @xmlonly <docref>(see <autoref label=\"sec:cap_rights\"/>)</docref> @endxmlonly ."]
    pub fn seL4_IRQHandler_SetNotification(
        _service: seL4_IRQHandler,
        notification: seL4_CPtr,
    ) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Clear\" label=\"irq_handlerclear\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Clear the handler capability from the IRQ slot @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:interrupts\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service The IRQ handler capability."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_IRQHandler_Clear(_service: seL4_IRQHandler) -> seL4_Error;
}
extern "C" {
    #[doc = " @xmlonly <manual name=\"Set\" label=\"domainset_set\"/> @endxmlonly"]
    #[doc = " @brief @xmlonly Change the domain of a thread. @endxmlonly"]
    #[doc = ""]
    #[doc = " @xmlonly"]
    #[doc = " <docref>See <autoref label=\"sec:domains\"/>.</docref>"]
    #[doc = " @endxmlonly"]
    #[doc = ""]
    #[doc = " @param[in] _service Capability allowing domain configuration."]
    #[doc = " @param[in] domain The thread's new domain."]
    #[doc = " @param[in] thread Capability to the TCB which is being operated on."]
    #[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
    #[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"domain\"/> @endxmlonly  is greater than  @xmlonly <texttt text=\"CONFIG_NUM_DOMAINS\"/> @endxmlonly ."]
    #[doc = " Or,  @xmlonly <texttt text=\"thread\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    #[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
    pub fn seL4_DomainSet_Set(
        _service: seL4_DomainSet,
        domain: seL4_Uint8,
        thread: seL4_TCB,
    ) -> seL4_Error;
}
pub const seL4_CapNull: _bindgen_ty_2 = 0;
pub const seL4_CapInitThreadTCB: _bindgen_ty_2 = 1;
pub const seL4_CapInitThreadCNode: _bindgen_ty_2 = 2;
pub const seL4_CapInitThreadVSpace: _bindgen_ty_2 = 3;
pub const seL4_CapIRQControl: _bindgen_ty_2 = 4;
pub const seL4_CapASIDControl: _bindgen_ty_2 = 5;
pub const seL4_CapInitThreadASIDPool: _bindgen_ty_2 = 6;
pub const seL4_CapIOPortControl: _bindgen_ty_2 = 7;
pub const seL4_CapIOSpace: _bindgen_ty_2 = 8;
pub const seL4_CapBootInfoFrame: _bindgen_ty_2 = 9;
pub const seL4_CapInitThreadIPCBuffer: _bindgen_ty_2 = 10;
pub const seL4_CapDomain: _bindgen_ty_2 = 11;
pub const seL4_CapSMMUSIDControl: _bindgen_ty_2 = 12;
pub const seL4_CapSMMUCBControl: _bindgen_ty_2 = 13;
pub const seL4_NumInitialCaps: _bindgen_ty_2 = 14;
pub type _bindgen_ty_2 = u32;
pub type seL4_SlotPos = seL4_Word;
#[repr(C)]
pub struct seL4_SlotRegion {
    pub start: seL4_SlotPos,
    pub end: seL4_SlotPos,
}
#[test]
fn bindgen_test_layout_seL4_SlotRegion() {
    assert_eq!(
        ::core::mem::size_of::<seL4_SlotRegion>(),
        16usize,
        concat!("Size of: ", stringify!(seL4_SlotRegion))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_SlotRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_SlotRegion))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_SlotRegion>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_SlotRegion),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_SlotRegion>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_SlotRegion),
            "::",
            stringify!(end)
        )
    );
}
#[repr(C)]
pub struct seL4_UntypedDesc {
    pub paddr: seL4_Word,
    pub sizeBits: seL4_Uint8,
    pub isDevice: seL4_Uint8,
    pub padding: [seL4_Uint8; 6usize],
}
#[test]
fn bindgen_test_layout_seL4_UntypedDesc() {
    assert_eq!(
        ::core::mem::size_of::<seL4_UntypedDesc>(),
        16usize,
        concat!("Size of: ", stringify!(seL4_UntypedDesc))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_UntypedDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_UntypedDesc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UntypedDesc>())).paddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UntypedDesc),
            "::",
            stringify!(paddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UntypedDesc>())).sizeBits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UntypedDesc),
            "::",
            stringify!(sizeBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UntypedDesc>())).isDevice as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UntypedDesc),
            "::",
            stringify!(isDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_UntypedDesc>())).padding as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_UntypedDesc),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
pub struct seL4_BootInfo {
    pub extraLen: seL4_Word,
    pub nodeID: seL4_NodeId,
    pub numNodes: seL4_Word,
    pub numIOPTLevels: seL4_Word,
    pub ipcBuffer: *mut seL4_IPCBuffer,
    pub empty: seL4_SlotRegion,
    pub sharedFrames: seL4_SlotRegion,
    pub userImageFrames: seL4_SlotRegion,
    pub userImagePaging: seL4_SlotRegion,
    pub ioSpaceCaps: seL4_SlotRegion,
    pub extraBIPages: seL4_SlotRegion,
    pub initThreadCNodeSizeBits: seL4_Word,
    pub initThreadDomain: seL4_Domain,
    pub untyped: seL4_SlotRegion,
    pub untypedList: [seL4_UntypedDesc; 230usize],
}
#[test]
fn bindgen_test_layout_seL4_BootInfo() {
    assert_eq!(
        ::core::mem::size_of::<seL4_BootInfo>(),
        3848usize,
        concat!("Size of: ", stringify!(seL4_BootInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_BootInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_BootInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_BootInfo>())).extraLen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfo),
            "::",
            stringify!(extraLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_BootInfo>())).nodeID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfo),
            "::",
            stringify!(nodeID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_BootInfo>())).numNodes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfo),
            "::",
            stringify!(numNodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_BootInfo>())).numIOPTLevels as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfo),
            "::",
            stringify!(numIOPTLevels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_BootInfo>())).ipcBuffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfo),
            "::",
            stringify!(ipcBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_BootInfo>())).empty as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfo),
            "::",
            stringify!(empty)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_BootInfo>())).sharedFrames as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfo),
            "::",
            stringify!(sharedFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_BootInfo>())).userImageFrames as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfo),
            "::",
            stringify!(userImageFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_BootInfo>())).userImagePaging as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfo),
            "::",
            stringify!(userImagePaging)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_BootInfo>())).ioSpaceCaps as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfo),
            "::",
            stringify!(ioSpaceCaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_BootInfo>())).extraBIPages as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfo),
            "::",
            stringify!(extraBIPages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<seL4_BootInfo>())).initThreadCNodeSizeBits as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfo),
            "::",
            stringify!(initThreadCNodeSizeBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_BootInfo>())).initThreadDomain as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfo),
            "::",
            stringify!(initThreadDomain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_BootInfo>())).untyped as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfo),
            "::",
            stringify!(untyped)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_BootInfo>())).untypedList as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfo),
            "::",
            stringify!(untypedList)
        )
    );
}
pub const seL4_BootInfoID_SEL4_BOOTINFO_HEADER_PADDING: seL4_BootInfoID = 0;
pub const seL4_BootInfoID_SEL4_BOOTINFO_HEADER_X86_VBE: seL4_BootInfoID = 1;
pub const seL4_BootInfoID_SEL4_BOOTINFO_HEADER_X86_MBMMAP: seL4_BootInfoID = 2;
pub const seL4_BootInfoID_SEL4_BOOTINFO_HEADER_X86_ACPI_RSDP: seL4_BootInfoID = 3;
pub const seL4_BootInfoID_SEL4_BOOTINFO_HEADER_X86_FRAMEBUFFER: seL4_BootInfoID = 4;
pub const seL4_BootInfoID_SEL4_BOOTINFO_HEADER_X86_TSC_FREQ: seL4_BootInfoID = 5;
pub const seL4_BootInfoID_SEL4_BOOTINFO_HEADER_FDT: seL4_BootInfoID = 6;
pub const seL4_BootInfoID_SEL4_BOOTINFO_HEADER_NUM: seL4_BootInfoID = 7;
pub const seL4_BootInfoID__enum_pad_seL4_BootInfoID: seL4_BootInfoID = 9223372036854775807;
pub type seL4_BootInfoID = u64;
#[repr(C)]
pub struct seL4_BootInfoHeader {
    pub id: seL4_Word,
    pub len: seL4_Word,
}
#[test]
fn bindgen_test_layout_seL4_BootInfoHeader() {
    assert_eq!(
        ::core::mem::size_of::<seL4_BootInfoHeader>(),
        16usize,
        concat!("Size of: ", stringify!(seL4_BootInfoHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<seL4_BootInfoHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(seL4_BootInfoHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_BootInfoHeader>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfoHeader),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seL4_BootInfoHeader>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seL4_BootInfoHeader),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub fn seL4_getArchFault(tag: seL4_MessageInfo_t) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_getFault(tag: seL4_MessageInfo_t) -> seL4_Fault_t;
}
extern "C" {
    pub fn seL4_isVMFault_tag(tag: seL4_MessageInfo_t) -> seL4_Bool;
}
extern "C" {
    pub fn seL4_isUnknownSyscall_tag(tag: seL4_MessageInfo_t) -> seL4_Bool;
}
extern "C" {
    pub fn seL4_isUserException_tag(tag: seL4_MessageInfo_t) -> seL4_Bool;
}
extern "C" {
    pub fn seL4_isNullFault_tag(tag: seL4_MessageInfo_t) -> seL4_Bool;
}
extern "C" {
    pub fn seL4_isCapFault_tag(tag: seL4_MessageInfo_t) -> seL4_Bool;
}
